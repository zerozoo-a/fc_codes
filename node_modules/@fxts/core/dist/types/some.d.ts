import IterableInfer from "./types/IterableInfer";
import ReturnValueType from "./types/ReturnValueType";
import Arrow from "./types/Arrow";
/**
 * Returns true if any of the values in Iterable/AsyncIterable pass `f` truth test
 *
 * @example
 * ```ts
 * some(a=> a, [null, 0, 1, false]); // true
 *
 * // with pipe
 * pipe(
 *  [{id:1, age: 27}, {id:2, age: 36}, {id:3, age: 42}],
 *  map(user => user.age),
 *  some(age => age > 40),
 * ); // true
 *
 * await pipe(
 *  Promise.resolve([{id:1, age: 27}, {id:2, age: 36}, {id:3, age: 42}]),
 *  map(user => user.age),
 *  some(age => age > 40),
 * ); // true
 *
 * // with toAsync
 * await pipe(
 *  [Promise.resolve({id:1, age: 27}), Promise.resolve({id:2, age: 36}), Promise.resolve({id:3, age: 42})],
 *  toAsync,
 *  map(user => user.age),
 *  some(age => age > 40),
 * ); // true
 * ```
 *
 * {@link https://codesandbox.io/s/fxts-some-inp3l | Try It}
 *
 * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},
 * {@link https://fxts.dev/docs/map | map}
 */
declare function some<A extends readonly []>(f: Arrow, iterable: A): false;
declare function some<A, B = unknown>(f: (a: A) => B, iterable: Iterable<A>): boolean;
declare function some<A, B = unknown>(f: (a: A) => B, iterable: AsyncIterable<A>): Promise<boolean>;
declare function some<A extends Iterable<unknown> | AsyncIterable<unknown>, B = unknown>(f: (a: IterableInfer<A>) => B): (a: A) => ReturnValueType<A, boolean>;
export default some;
//# sourceMappingURL=some.d.ts.map