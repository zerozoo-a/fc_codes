import { AsyncEntryPredicate, ConditionalAsyncEntryPredicate, EntryPredicate } from "./types/EntryPredicate";
/**
 *
 * Returns a partial copy of an object which contains only the keys that satisfy the supplied predicate.
 *
 * @example
 * ```ts
 * const obj = { a: 1, b: "2", c: true };
 * pickBy(([key, value]) => key === "a" || value === true, obj); // { a: 1, c: true }
 *
 * // asynchronous predicate
 * await pickBy(async ([key, value]) => key === "a" || value === true, obj); // { a: 1, c: true }
 *
 * // Using with the `pipe` function
 * pipe(
 *   obj,
 *   pickBy(([key, value]) => key === "a" || value === true)
 * );
 *
 * await pipe(
 *   obj,
 *   pickBy(async ([key, value]) => key === "a" || value === true)
 * );
 * ```
 * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/pick | pick},
 */
declare function pickBy<T extends object, F extends AsyncEntryPredicate<T>>(f: F, obj: T): Promise<Partial<T>>;
declare function pickBy<T extends object, F extends AsyncEntryPredicate<T>>(f: F): (obj: T) => Promise<Partial<T>>;
declare function pickBy<T extends object, F extends EntryPredicate<T>>(f: F, obj: T): Partial<T>;
declare function pickBy<T extends object, F extends EntryPredicate<T>>(f: F): (obj: T) => Partial<T>;
declare function pickBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(f: F, obj: T): Partial<T> | Promise<Partial<T>>;
declare function pickBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(f: F): (obj: T) => Partial<T> | Promise<Partial<T>>;
export default pickBy;
//# sourceMappingURL=pickBy.d.ts.map