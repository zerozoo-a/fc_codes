import ReturnZipType from "../types/ReturnZipType";
import { UniversalIterable } from "../types/Utils";
/**
 * Merges the values of each of the arrays with the values at the corresponding position together.
 * Useful when you have separate data sources that are coordinated through matching array indices.
 *
 * @example
 * ```ts
 * const iter = zip([1, 2, 3, 4], [5, 6, 7, 8]);
 * iter.next() // {done:false, value: [1, 5]}
 * iter.next() // {done:false, value: [2, 6]}
 * iter.next() // {done:false, value: [3, 7]}
 * iter.next() // {done:false, value: [4, 8]}
 * iter.next() // {done:true, value: undefined}
 *
 * // with pipe
 * pipe(
 *  [5, 6, 7, 8],
 *  zip([1, 2, 3, 4]),
 *  toArray,
 * ); // [[1, 5], [2, 6], [3, 7], [4, 8]]
 *
 * await pipe(
 *  Promise.resolve([5, 6, 7, 8]),
 *  zip([1, 2, 3, 4]),
 *  toArray,
 * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]
 *
 * // with toAsync
 * await pipe(
 *  [Promise.resolve(5), Promise.resolve(6), Promise.resolve(7), Promise.resolve(8)],
 *  toAsync,
 *  zip([1, 2, 3, 4]),
 *  toArray,
 * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]
 * ```
 *
 * {@link https://codesandbox.io/s/fxts-zip-81jnh | Try It}
 *
 * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},
 * {@link https://fxts.dev/docs/toArray | toArray}
 */
declare function zip<T extends UniversalIterable, TS extends UniversalIterable[]>(a: T): (...args: TS) => ReturnZipType<[T, ...TS]>;
declare function zip<T extends UniversalIterable[]>(...args: T): ReturnZipType<[...T]>;
export default zip;
//# sourceMappingURL=zip.d.ts.map