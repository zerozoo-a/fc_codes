import IterableInfer from "../types/IterableInfer";
import type { DeepFlat, DeepFlatSync } from "../types/DeepFlat";
import Awaited from "../types/Awaited";
declare type ReturnFlatType<A extends Iterable<unknown> | AsyncIterable<unknown>, B extends number = 1> = A extends Iterable<unknown> ? IterableIterator<DeepFlatSync<IterableInfer<A>, B>> : A extends AsyncIterable<unknown> ? AsyncIterableIterator<DeepFlat<Awaited<IterableInfer<A>>, B>> : never;
/**
 * Returns flattened Iterable/AsyncIterable.
 * If first argument is number, more perform flatten `flat(2, [[[1,2]]]) // [1,2]`
 *
 * @example
 * ```ts
 * const iter = flat([1,[2,3],[[4,5]]]);
 * iter.next() // {done:false, value: 1}
 * iter.next() // {done:false, value: 2}
 * iter.next() // {done:false, value: 3}
 * iter.next() // {done:false, value: [4, 5]}
 * iter.next() // {done:true, value: undefined}
 *
 * // with pipe
 * pipe(
 *  [1,[2, 3],[[4, 5]]],
 *  flat,
 *  toArray,
 * ); // [1, 2, 3, [4, 5]]
 *
 * await pipe(
 *  Promise.resolve([1,[2, 3],[[4, 5]]]),
 *  flat,
 *  toArray,
 * ); // [1, 2, 3, [4, 5]]
 * ```
 *
 * {@link https://codesandbox.io/s/fxts-flat-6t2in | Try It}
 *
 * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},
 * {@link https://fxts.dev/docs/toArray | toArray}
 */
declare function flat<A extends Iterable<unknown> | AsyncIterable<unknown>, B extends number = 1>(iterator: A, depth?: B): ReturnFlatType<A, B>;
export default flat;
//# sourceMappingURL=flat.d.ts.map