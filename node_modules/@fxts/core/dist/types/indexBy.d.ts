import Key from "./types/Key";
import ReturnValueType from "./types/ReturnValueType";
import IterableInfer from "./types/IterableInfer";
/**
 * Given `f` that generates a key,
 * turns a list of objects into an object indexing the objects by the given key.
 * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.
 *
 * @example
 * ```ts
 * const given = [
 *   { category: "clothes", desc: "good" },
 *   { category: "pants", desc: "bad" },
 *   { category: "shoes", desc: "not bad" },
 * ];
 *
 * indexBy(a => a.category, given);
 * // {
 * //   clothes: { category: "clothes", desc: "good" },
 * //   pants: { category: "pants", desc: "bad" },
 * //   shoes: { category: "shoes", desc: "not bad" },
 * // };
 * ```
 *
 * {@link https://codesandbox.io/s/fxts-indexby-zpeok | Try It}
 */
declare function indexBy<A, B extends Key>(f: (a: A) => B, iterable: Iterable<A>): {
    [K in B]: A;
};
declare function indexBy<A, B extends Key>(f: (a: A) => B | Promise<B>, iterable: AsyncIterable<A>): Promise<{
    [K in B]: A;
}>;
declare function indexBy<A extends Iterable<unknown> | AsyncIterable<unknown>, B extends Key>(f: (a: IterableInfer<A>) => B | Promise<B>): (iterable: A) => ReturnValueType<A, {
    [K in B]: IterableInfer<A>;
}>;
export default indexBy;
//# sourceMappingURL=indexBy.d.ts.map