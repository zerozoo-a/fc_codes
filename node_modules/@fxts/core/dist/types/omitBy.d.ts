import { AsyncEntryPredicate, ConditionalAsyncEntryPredicate, EntryPredicate } from "./types/EntryPredicate";
/**
 *
 * Returns a partial copy of an object containing only the keys that satisfy the supplied predicate.
 *
 * @example
 * ```ts
 * const obj = { a: 1, b: "2", c: true };
 * omitBy(([key, value]) => key === "a" || value === true, obj); // { b: "2" }
 *
 * // asynchronous predicate
 * await omitBy(async ([key, value]) => key === "a" || value === true, obj); // { b: "2" }
 *
 * // Using with the `pipe` function
 * pipe(
 *   obj,
 *   omitBy(([key, value]) => key === "a" || value === true)
 * );
 *
 * await pipe(
 *   obj,
 *   omitBy(async ([key, value]) => key === "a" || value === true)
 * );
 * ```
 * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/omit | omit},
 */
declare function omitBy<T extends object, F extends AsyncEntryPredicate<T>>(f: F, obj: T): Promise<Partial<T>>;
declare function omitBy<T extends object, F extends AsyncEntryPredicate<T>>(f: F): (obj: T) => Promise<Partial<T>>;
declare function omitBy<T extends object, F extends EntryPredicate<T>>(f: F, obj: T): Partial<T>;
declare function omitBy<T extends object, F extends EntryPredicate<T>>(f: F): (obj: T) => Partial<T>;
declare function omitBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(f: F, obj: T): Partial<T> | Promise<Partial<T>>;
declare function omitBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(f: F): (obj: T) => Partial<T> | Promise<Partial<T>>;
export default omitBy;
//# sourceMappingURL=omitBy.d.ts.map