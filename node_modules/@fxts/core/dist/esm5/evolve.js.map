{"version":3,"file":"evolve.js","sourceRoot":"","sources":["../../src/evolve.ts"],"names":[],"mappings":";AAAA,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,QAAQ,MAAM,YAAY,CAAC;AAwClC,SAAS,MAAM,CACb,cAAiB,EACjB,GAAO;IAEP,IAAI,GAAG,KAAK,SAAS,EAAE;QACrB,OAAO,UAAC,GAAM,IAAK,OAAA,MAAM,CAAC,cAAc,EAAE,GAAG,CAAC,EAA3B,CAA2B,CAAC;KAChD;IACD,OAAO,IAAI,CACT,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EACnB,UAAC,OAAO;QACN,OAAA,OAAO,CAAC,GAAG,CAAC,UAAC,EAAM;;gBAAN,KAAA,aAAM,EAAL,CAAC,QAAA,EAAE,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,EAAE,CAAC,MAAA,cAAc,CAAC,CAAC,CAAC,mCAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;SAAA,CAAC;IAAhE,CAAgE,EAClE,MAAM,CAAC,WAAW,CACnB,CAAC;AACJ,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import pipe from \"./pipe\";\nimport identity from \"./identity\";\n\ntype Transformation<O extends Record<string, any>> = {\n  [K in keyof O]?: (value: O[K]) => any;\n};\n\ntype EvolveReturnType<\n  O extends Record<string, any>,\n  T extends Transformation<O>,\n> = {\n  [K in keyof O]: T[K] extends (value: O[K]) => any ? ReturnType<T[K]> : O[K];\n};\n\n/**\n * Creates a new object by recursively evolving a shallow copy of object, according to the transformation functions.\n *\n * @example\n * ```ts\n * const add1String = (a: number) => String(a + 1);\n * const obj = { a: 1, b: 2, c: { d: 3, e: 4 }, f: true };\n * const transformation = {\n *   a: add1String,\n *   b: add1String,\n *   c: (obj: { d: number; e: number }) =>\n *     evolve({ d: add1String, e: add1String }, obj),\n * };\n * evolve(transformation, obj);\n * // { a: \"2\", b: \"3\", c: { d: \"4\", e: \"5\" }, f: true }\n * ```\n */\n\nfunction evolve<O extends Record<string, any>, T extends Transformation<O>>(\n  transformation: T,\n): (obj: O) => EvolveReturnType<O, T>;\n\nfunction evolve<O extends Record<string, any>, T extends Transformation<O>>(\n  transformation: T,\n  obj: O,\n): EvolveReturnType<O, T>;\n\nfunction evolve<O extends Record<string, any>, T extends Transformation<O>>(\n  transformation: T,\n  obj?: O,\n): ((obj: O) => EvolveReturnType<O, T>) | EvolveReturnType<O, T> {\n  if (obj === undefined) {\n    return (obj: O) => evolve(transformation, obj);\n  }\n  return pipe(\n    Object.entries(obj),\n    (entries) =>\n      entries.map(([k, v]) => [k, (transformation[k] ?? identity)(v)]),\n    Object.fromEntries,\n  );\n}\n\nexport default evolve;\n"]}