{"version":3,"file":"find.js","sourceRoot":"","sources":["../../src/find.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,eAAe,CAAC;AACnC,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,mBAAmB,CAAC;AA6BhE,SAAS,IAAI,CACX,CAAmC,EACnC,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAA,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAqD;QAArE,CAAqE,CAAC;KACzE;IACD,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;KAClC;IACD,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;KAClC;IACD,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,IAAI,CAAC","sourcesContent":["import filter from \"./Lazy/filter\";\nimport head from \"./head\";\nimport { isAsyncIterable, isIterable } from \"./_internal/utils\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport IterableInfer from \"./types/IterableInfer\";\n\n/**\n * Looks through each value in Iterable/AsyncIterable, returning the first one that passes a truth test `f`,\n * or `undefined` if no value passes the test.\n *\n * @example\n * ```ts\n * find((a) => a === 2, [1, 2, 3, 4]); // 2\n *\n * find((a) => a === \"r\", \"marpple\"); // 'r'\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-find-uhl0o | Try It}\n */\nfunction find<T>(f: (a: T) => unknown, iterable: Iterable<T>): T | undefined;\n\nfunction find<T>(\n  f: (a: T) => unknown,\n  iterable: AsyncIterable<T>,\n): Promise<T | undefined>;\n\nfunction find<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>) => unknown,\n  iterable?: T,\n): (iterable: T) => ReturnValueType<T, IterableInfer<T> | undefined>;\n\nfunction find<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>) => unknown,\n  iterable?: T,\n):\n  | (IterableInfer<T> | undefined)\n  | Promise<IterableInfer<T> | undefined>\n  | ((iterable: T) => ReturnValueType<T, IterableInfer<T> | undefined>) {\n  if (iterable === undefined) {\n    return (iterable: T) =>\n      find(f, iterable) as ReturnValueType<T, IterableInfer<T> | undefined>;\n  }\n  if (isIterable<IterableInfer<T>>(iterable)) {\n    return head(filter(f, iterable));\n  }\n  if (isAsyncIterable<IterableInfer<T>>(iterable)) {\n    return head(filter(f, iterable));\n  }\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default find;\n"]}