{"version":3,"file":"findIndex.js","sourceRoot":"","sources":["../../src/findIndex.ts"],"names":[],"mappings":";AAAA,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,YAAY,MAAM,qBAAqB,CAAC;AAC/C,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,KAAK,MAAM,SAAS,CAAC;AAI5B,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,mBAAmB,CAAC;AA2BhE,SAAS,SAAS,CAChB,CAAmC,EACnC,QAAY;IAEZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAA,SAAS,CAAC,CAAC,EAAE,QAAe,CAA+B;QAA3D,CAA2D,CAAC;KAC/D;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CACT,YAAY,CAAC,QAAQ,CAAyC,EAC9D,IAAI,CAAC,UAAC,EAAK;gBAAL,KAAA,aAAK,EAAF,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,CAAC,CAAC;QAAJ,CAAI,CAAC,EACrB,UAAC,GAAG,IAAK,OAAA,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAC7B,CAAC;KACH;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,IAAI,CACT,YAAY,CAAC,QAAQ,CAA8C,EACnE,IAAI,CAAC,UAAC,EAAK;gBAAL,KAAA,aAAK,EAAF,CAAC,QAAA;YAAM,OAAA,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;QAAX,CAAW,CAAC,EAC5B,UAAC,GAAG,IAAK,OAAA,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAC7B,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,SAAS,CAAC","sourcesContent":["import find from \"./find\";\nimport zipWithIndex from \"./Lazy/zipWithIndex\";\nimport pipe from \"./pipe\";\nimport pipe1 from \"./pipe1\";\nimport Arrow from \"./types/Arrow\";\nimport IterableInfer from \"./types/IterableInfer\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport { isAsyncIterable, isIterable } from \"./_internal/utils\";\n\n/**\n * Returns the index of the first element of Iterable/AsyncIterable which matches f, or -1 if no element matches.\n *\n * @example\n * ```ts\n * const arr = [{a:1}, {a:2}, {a:3}]\n * findIndex((obj) =>  obj.a === 1, arr); // 0\n * findIndex((obj) =>  obj.a === 2, arr); // 1\n * findIndex((obj) =>  obj.a === 4, arr); // -1\n * ```\n */\nfunction findIndex<T extends readonly []>(f: Arrow, iterable: T): -1;\n\nfunction findIndex<T>(f: (a: T) => unknown, iterable: Iterable<T>): number;\n\nfunction findIndex<T>(\n  f: (a: T) => unknown,\n  iterable: AsyncIterable<T>,\n): Promise<number>;\n\nfunction findIndex<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>) => unknown,\n  iterable?: T,\n): (iterable: T) => ReturnValueType<T, number>;\n\nfunction findIndex<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>) => unknown,\n  iterable?: T,\n): number | Promise<number> | ((iterable: T) => ReturnValueType<T, number>) {\n  if (iterable === undefined) {\n    return (iterable: T) =>\n      findIndex(f, iterable as any) as ReturnValueType<T, number>;\n  }\n\n  if (isIterable(iterable)) {\n    return pipe(\n      zipWithIndex(iterable) as Iterable<[number, IterableInfer<T>]>,\n      find(([, a]) => f(a)),\n      (res) => (res ? res[0] : -1),\n    );\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return pipe(\n      zipWithIndex(iterable) as AsyncIterable<[number, IterableInfer<T>]>,\n      find(([, a]) => pipe1(a, f)),\n      (res) => (res ? res[0] : -1),\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default findIndex;\n"]}