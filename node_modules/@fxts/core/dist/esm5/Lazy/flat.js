import { __awaiter, __generator, __read } from "tslib.js";
import concurrent, { isConcurrent } from "./concurrent.js";
import last from "../last.js";
import { empty, isAsyncIterable, isIterable } from "../_internal/utils.js";
import append from "./append.js";
import concat from "./concat.js";
var isFlatAble = function (a) {
    return typeof a !== "string" && isIterable(a);
};
function sync(iterable, depth) {
    var _a;
    var iterator = iterable[Symbol.iterator]();
    var iteratorStack = [
        iterator,
    ];
    return _a = {},
        _a[Symbol.iterator] = function () {
            return this;
        },
        _a.next = function () {
            var iterator = last(iteratorStack);
            if (!iterator) {
                return { done: true, value: undefined };
            }
            var _a = iterator.next(), value = _a.value, done = _a.done;
            if (done) {
                iteratorStack.pop();
                return this.next();
            }
            if (isFlatAble(value) && iteratorStack.length < depth + 1) {
                iteratorStack.push(value[Symbol.iterator]());
                return this.next();
            }
            return {
                done: false,
                value: value,
            };
        },
        _a;
}
function asyncConcurrent(iterable, depth) {
    var _a;
    var _this = this;
    var originIterator = iterable[Symbol.asyncIterator]();
    var prevItem = Promise.resolve();
    var flattenIterator = empty();
    var finished = false;
    var settlementQueue = [];
    var fillItem = function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, done, value;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, originIterator.next()];
                case 1:
                    _a = _b.sent(), done = _a.done, value = _a.value;
                    if (done) {
                        return [2 /*return*/, false];
                    }
                    if (isFlatAble(value)) {
                        flattenIterator = concat(sync(value, depth - 1), flattenIterator);
                    }
                    else {
                        flattenIterator = append(value, flattenIterator);
                    }
                    return [2 /*return*/, true];
            }
        });
    }); };
    var pullItem = function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, value, done, hasItem;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (finished) {
                        return [2 /*return*/, { done: true, value: undefined }];
                    }
                    _a = flattenIterator.next(), value = _a.value, done = _a.done;
                    if (!done) return [3 /*break*/, 2];
                    return [4 /*yield*/, fillItem()];
                case 1:
                    hasItem = _b.sent();
                    if (hasItem) {
                        return [2 /*return*/, pullItem()];
                    }
                    return [2 /*return*/, { done: true, value: undefined }];
                case 2: return [2 /*return*/, { done: false, value: value }];
            }
        });
    }); };
    var resolveItem = function (_a) {
        var done = _a.done, value = _a.value;
        if (done || finished) {
            while (settlementQueue.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var _b = __read(settlementQueue.shift(), 1), resolve_1 = _b[0];
                resolve_1({ done: true, value: undefined });
            }
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        var _c = __read(settlementQueue.shift(), 1), resolve = _c[0];
        resolve({ done: done, value: value });
    };
    var catchItem = function (err) {
        finished = true;
        // eslint-disable-next-line
        var _a = __read(settlementQueue.shift(), 2), _ = _a[0], reject = _a[1];
        reject(err);
    };
    return _a = {},
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            settlementQueue.push([resolve, reject]);
                            prevItem = prevItem
                                .then(function () { return pullItem(); })
                                .then(resolveItem)
                                .catch(catchItem);
                        })];
                });
            });
        },
        _a;
}
function asyncSequential(iterable, depth) {
    var _a;
    var iterator = iterable[Symbol.asyncIterator]();
    var iteratorStack = [
        iterator,
    ];
    return _a = {},
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var iterator, _a, value, done;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            iterator = last(iteratorStack);
                            if (!iterator) {
                                return [2 /*return*/, { done: true, value: undefined }];
                            }
                            return [4 /*yield*/, iterator.next()];
                        case 1:
                            _a = _b.sent(), value = _a.value, done = _a.done;
                            if (done) {
                                iteratorStack.pop();
                                return [2 /*return*/, this.next()];
                            }
                            if (isFlatAble(value) && iteratorStack.length < depth + 1) {
                                iteratorStack.push(value[Symbol.iterator]());
                                return [2 /*return*/, this.next()];
                            }
                            return [2 /*return*/, {
                                    done: false,
                                    value: value,
                                }];
                    }
                });
            });
        },
        _a;
}
function async(iterable, depth) {
    var _a;
    var _iterator = null;
    return _a = {
            next: function (_concurrent) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        if (_iterator === null) {
                            _iterator = isConcurrent(_concurrent)
                                ? asyncConcurrent(concurrent(_concurrent.length, iterable), depth)
                                : asyncSequential(iterable, depth);
                        }
                        return [2 /*return*/, _iterator.next(_concurrent)];
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a;
}
function flat(iterable, depth) {
    if (depth === void 0) { depth = 1; }
    if (isIterable(iterable)) {
        return sync(iterable, depth);
    }
    if (isAsyncIterable(iterable)) {
        return async(iterable, depth);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default flat;
//# sourceMappingURL=flat.js.map