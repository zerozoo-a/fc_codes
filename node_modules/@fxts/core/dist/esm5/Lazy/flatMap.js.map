{"version":3,"file":"flatMap.js","sourceRoot":"","sources":["../../../src/Lazy/flatMap.ts"],"names":[],"mappings":"AAAA,OAAO,GAAG,MAAM,OAAO,CAAC;AACxB,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AA8EjE,SAAS,OAAO,CAId,CAA6B,EAC7B,QAAY;IAEZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAe,CAAC,CAAQ,CAAC;QAC9C,CAAC,CAAC;KACH;IAED,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAe,CAAC,CAAQ,CAAC;KAC7C;IAED,IAAI,eAAe,CAA4B,QAAQ,CAAC,EAAE;QACxD,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAe,CAAC,CAAQ,CAAC;KAC7C;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import map from \"./map\";\nimport flat from \"./flat\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport Awaited from \"../types/Awaited\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport type { DeepFlat, DeepFlatSync } from \"../types/DeepFlat\";\n\ntype ReturnFlatMapType<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n> = A extends Iterable<unknown>\n  ? IterableIterator<DeepFlatSync<B, 1>>\n  : A extends AsyncIterable<unknown>\n  ? AsyncIterableIterator<DeepFlat<Awaited<B>, 1>>\n  : never;\n\n/**\n * Returns flattened Iterable/AsyncIterable of values by running each element\n * flattening the mapped results.\n *\n * @example\n * ```ts\n * const iter = flatMap(s => s.split(\" \"), [\"It is\", \"a good\", \"day\"]);\n * iter.next() // {done:false, value: \"It\"}\n * iter.next() // {done:false, value: \"is\"}\n * iter.next() // {done:false, value: \"a\"}\n * iter.next() // {done:false, value: \"good\"},\n * iter.next() // {done:false, value: \"day\"},\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [\"It is\", \"a good\", \"day\"],\n *  flatMap(s => s.split(\" \")),\n *  toArray,\n * ); // [\"It\", \"is\", \"a\", \"good\", \"day\"]\n *\n * await pipe(\n *  Promise.resolve([\"It is\", \"a good\", \"day\"]),\n *  flatMap(s => s.split(\" \")),\n *  toArray,\n * ); // [\"It\", \"is\", \"a\", \"good\", \"day\"]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([\"It is\", \"a good\", \"day\"]),\n *  toAsync,\n *  flatMap(async (s) => s.split(\" \")),\n *  toArray,\n * ); // [\"It\", \"is\", \"a\", \"good\", \"day\"]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-flatmap-3g9k8 | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction flatMap<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<DeepFlatSync<B, 1>>;\n\nfunction flatMap<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<DeepFlat<Awaited<B>, 1>>;\n\nfunction flatMap<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(f: (a: IterableInfer<A>) => B): (iterable: A) => ReturnFlatMapType<A, B>;\n\nfunction flatMap<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): (iterable: A) => ReturnFlatMapType<A, B>;\n\nfunction flatMap<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): ReturnFlatMapType<A, B> | ((iterable: A) => ReturnFlatMapType<A, B>) {\n  if (iterable === undefined) {\n    return (iterable: A) => {\n      return flat(map(f, iterable as any)) as any;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return flat(map(f, iterable as any)) as any;\n  }\n\n  if (isAsyncIterable<Awaited<IterableInfer<A>>>(iterable)) {\n    return flat(map(f, iterable as any)) as any;\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default flatMap;\n"]}