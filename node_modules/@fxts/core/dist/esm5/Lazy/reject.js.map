{"version":3,"file":"reject.js","sourceRoot":"","sources":["../../../src/Lazy/reject.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,OAAO,KAAK,MAAM,UAAU,CAAC;AAC7B,OAAO,GAAG,MAAM,QAAQ,CAAC;AACzB,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAsEjE,SAAS,MAAM,CAIb,CAA6B,EAC7B,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,MAAM,CAAC,CAAC,EAAE,QAAe,CAG/B,CAAC;QACJ,CAAC,CAAC;KACH;IAED,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAhB,CAAgB,EAAE,QAAQ,CAAC,CAAC;KAClD;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAhB,CAAgB,EAAE,QAAQ,CAAC,CAAC;KAClD;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import filter from \"./filter\";\nimport pipe1 from \"../pipe1\";\nimport not from \"../not\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\n\n/**\n * The opposite of {@link https://fxts.dev/docs/filter | filter}\n * Iterable/AsyncIterable of all elements `f` returns falsy for\n *\n * @example\n * ```ts\n * const iter = reject((a)=> a % 2 === 0, [0, 1, 2, 3, 4, 5, 6]);\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 3}\n * iter.next() // {done:false, value: 5}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [0, 1, 2, 3, 4, 5, 6],\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  toAsync,\n *  reject(async a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(0), Promise.resolve(1), Promise.resolve(2),\n *   Promise.resolve(3), Promise.resolve(4), Promise.resolve(5), Promise.resolve(6)],\n *  toAsync,\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-reject-vrc7d | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction reject<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction reject<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction reject<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): (iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>;\n\nfunction reject<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | IterableIterator<IterableInfer<A>>\n  | AsyncIterableIterator<IterableInfer<A>>\n  | ((iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnIterableIteratorType<A, IterableInfer<A>> => {\n      return reject(f, iterable as any) as ReturnIterableIteratorType<\n        A,\n        IterableInfer<A>\n      >;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return filter((a) => pipe1(f(a), not), iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return filter((a) => pipe1(f(a), not), iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default reject;\n"]}