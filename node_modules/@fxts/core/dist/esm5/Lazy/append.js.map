{"version":3,"file":"append.js","sourceRoot":"","sources":["../../../src/Lazy/append.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAC5E,OAAO,UAAU,EAAE,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAIxD,SAAU,IAAI,CAAI,CAAI,EAAE,QAAqB;;;oBAC3C,sBAAA,SAAO,QAAQ,CAAA,EAAA;;gBAAf,SAAe,CAAC;gBAChB,qBAAM,CAAC,EAAA;;gBAAP,SAAO,CAAC;;;;CACT;AAED,SAAS,eAAe,CACtB,CAAa,EACb,QAA0B;;IAE1B,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAClD,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB;QACE,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;QACK,OAAI,GAAV;;;;;;;4BACE,IAAI,QAAQ,EAAE;gCACZ,sBAAO,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,EAAC;6BACzC;4BACuB,qBAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;4BAAvC,KAAkB,SAAqB,EAArC,KAAK,WAAA,EAAE,IAAI,UAAA;4BACnB,IAAI,QAAQ,EAAE;gCACZ,sBAAO,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,EAAC;6BACzC;iCACG,IAAI,EAAJ,wBAAI;4BACN,QAAQ,GAAG,IAAI,CAAC;mCACP,IAAI,EAAE,KAAK;4BAAS,qBAAM,CAAC,EAAA;gCAApC,uBAAsB,QAAK,GAAE,SAAO,OAAG;gCAEvC,sBAAO,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,EAAC;;;;SAE1B;WACD;AACJ,CAAC;AAED,SAAS,KAAK,CACZ,CAAa,EACb,QAA0B;;IAE1B,IAAI,QAAQ,GAA4B,IAAI,CAAC;IAC7C;QACE,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;QAEK,OAAI,GAAV,UAAW,WAAgB;;;oBACzB,IAAI,QAAQ,KAAK,IAAI,EAAE;wBACrB,QAAQ,GAAG,YAAY,CAAC,WAAW,CAAC;4BAClC,CAAC,CAAC,eAAe,CAAC,CAAC,EAAE,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;4BAC9D,CAAC,CAAC,eAAe,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;qBAClC;oBACD,sBAAO,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAC;;;SACnC;WACD;AACJ,CAAC;AAqDD,SAAS,MAAM,CACb,CAAI,EACJ,QAAyC;IAKzC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAA,MAAM,CAAC,CAAC,EAAE,QAAe,CAAqC;QAA9D,CAA8D,CAAC;KAClE;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC/D;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\nimport Awaited from \"../types/Awaited\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\n\nfunction* sync<A>(a: A, iterable: Iterable<A>) {\n  yield* iterable;\n  yield a;\n}\n\nfunction asyncSequential<A>(\n  a: Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let finished = false;\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next() {\n      if (finished) {\n        return { done: true, value: undefined };\n      }\n      const { value, done } = await iterator.next();\n      if (finished) {\n        return { done: true, value: undefined };\n      }\n      if (done) {\n        finished = true;\n        return { done: false, value: await a };\n      } else {\n        return { done, value };\n      }\n    },\n  };\n}\n\nfunction async<A>(\n  a: Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let iterator: AsyncIterator<A> | null = null;\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    async next(_concurrent: any) {\n      if (iterator === null) {\n        iterator = isConcurrent(_concurrent)\n          ? asyncSequential(a, concurrent(_concurrent.length, iterable))\n          : asyncSequential(a, iterable);\n      }\n      return iterator.next(_concurrent);\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable containing the contents of the given iterable,\n * followed by the given element.\n *\n * @example\n * ```ts\n * const iter = append(4, [1,2,3]);\n * iter.next() // {done: false, value: 1}\n * iter.next() // {done: false, value: 2}\n * iter.next() // {done: false, value: 3}\n * iter.next() // {done: false, value: 4}\n * iter.next() // {done: true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [1,2,3],\n *  append(4),\n *  toArray,\n * ); // [1,2,3,4]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3]),\n *  append(4),\n *  toArray,\n * ); // [1, 2, 3, 4]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n *  toAsync,\n *  append(4),\n *  toArray,\n * ); // [1, 2, 3, 4]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-append-civf7 | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction append<A, B extends Iterable<A> | AsyncIterable<Awaited<A>>>(\n  a: A,\n): (iterable: B) => ReturnIterableIteratorType<B, Awaited<A>>;\n\nfunction append<A>(a: A, iterable: Iterable<A>): IterableIterator<A>;\n\nfunction append<A>(\n  a: A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction append<A, B extends Iterable<A> | AsyncIterable<A>>(\n  a: A,\n  iterable?: Iterable<A> | AsyncIterable<A>,\n):\n  | IterableIterator<A>\n  | AsyncIterableIterator<A>\n  | ((iterable: B) => ReturnIterableIteratorType<B, A>) {\n  if (iterable === undefined) {\n    return (iterable: B) =>\n      append(a, iterable as any) as ReturnIterableIteratorType<B, A>;\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(isPromise(a) ? a : Promise.resolve(a), iterable);\n  }\n\n  if (isIterable(iterable)) {\n    return sync(a, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default append;\n"]}