import { __awaiter, __generator } from "tslib.js";
import { isAsyncIterable, isIterable, isPromise } from "../_internal/utils.js";
import { AsyncFunctionException } from "../_internal/error.js";
function sync(f, iterable) {
    var _a;
    var iterator = iterable[Symbol.iterator]();
    return _a = {
            next: function () {
                var _a = iterator.next(), done = _a.done, value = _a.value;
                if (done) {
                    return {
                        done: true,
                        value: undefined,
                    };
                }
                var res = f(value);
                if (isPromise(res)) {
                    throw new AsyncFunctionException();
                }
                return {
                    done: false,
                    value: res,
                };
            }
        },
        _a[Symbol.iterator] = function () {
            return this;
        },
        _a;
}
function async(f, iterable) {
    var _a;
    var iterator = iterable[Symbol.asyncIterator]();
    return _a = {
            next: function (_concurrent) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, done, value;
                    var _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0: return [4 /*yield*/, iterator.next(_concurrent)];
                            case 1:
                                _a = _c.sent(), done = _a.done, value = _a.value;
                                if (done)
                                    return [2 /*return*/, { done: done, value: value }];
                                _b = {
                                    done: false
                                };
                                return [4 /*yield*/, f(value)];
                            case 2: return [2 /*return*/, (_b.value = _c.sent(),
                                    _b)];
                        }
                    });
                });
            }
        },
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a;
}
function map(f, iterable) {
    if (iterable === undefined) {
        return function (iterable) {
            return map(f, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(f, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default map;
//# sourceMappingURL=map.js.map