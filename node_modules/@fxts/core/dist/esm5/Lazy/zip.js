import { __awaiter, __generator, __read, __spreadArray } from "tslib.js";
import map from "./map.js";
import pipe from "../pipe.js";
import toArray from "../toArray.js";
import toAsync from "./toAsync.js";
import { isAsyncIterable, isIterable, toIterator } from "../_internal/utils.js";
import range from "./range.js";
import takeWhile from "./takeWhile.js";
import every from "../every.js";
function sync(iterable) {
    var iterators = toArray(map(function (a) { return toIterator(a); }, iterable));
    return pipe(range(Infinity), map(function () { return toArray(map(function (it) { return it.next(); }, iterators)); }), takeWhile(every(function (cur2) { return !cur2.done; })), map(function (cur1) { return toArray(map(function (cur2) { return cur2.value; }, cur1)); }));
}
function async(iterable) {
    var _a;
    var iterators = toArray(map(toIterator, iterable));
    return _a = {},
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.next = function (_concurrent) {
            return __awaiter(this, void 0, void 0, function () {
                var headIterators, hasDone;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, pipe(toAsync(iterators), map(function (it) { return it.next(_concurrent); }), toArray)];
                        case 1:
                            headIterators = _a.sent();
                            hasDone = headIterators.some(function (it) { return it.done; });
                            if (hasDone) {
                                return [2 /*return*/, { done: true, value: undefined }];
                            }
                            return [2 /*return*/, {
                                    done: false,
                                    value: headIterators.map(function (it) { return it.value; }),
                                }];
                    }
                });
            });
        },
        _a;
}
function zip() {
    var iterables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        iterables[_i] = arguments[_i];
    }
    if (iterables.length < 2) {
        return function () {
            var iterables2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                iterables2[_i] = arguments[_i];
            }
            return zip.apply(void 0, __spreadArray(__spreadArray([], __read(iterables), false), __read(iterables2), false));
        };
    }
    if (iterables.some(function (a) { return !isIterable(a) && !isAsyncIterable(a); })) {
        throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
    }
    var hasAsyncIterable = iterables.some(function (iterable) {
        return isAsyncIterable(iterable);
    });
    if (hasAsyncIterable) {
        return async(iterables);
    }
    return sync(iterables);
}
export default zip;
//# sourceMappingURL=zip.js.map