import { __read, __spreadArray } from "tslib.js";
import { isAsyncIterable } from "../_internal/utils.js";
var Concurrent = /** @class */ (function () {
    function Concurrent(length) {
        this.length = length;
    }
    Concurrent.of = function (length) {
        return new Concurrent(length);
    };
    return Concurrent;
}());
export { Concurrent };
export var isConcurrent = function (concurrent) {
    return concurrent instanceof Concurrent;
};
function concurrent(length, iterable) {
    var _a;
    if (iterable === undefined) {
        return function (iterable) {
            return concurrent(length, iterable);
        };
    }
    if (length === Infinity) {
        throw new RangeError("'length' cannot be infinite");
    }
    if (length <= 0) {
        throw new RangeError("'length' must be over 0");
    }
    if (!isAsyncIterable(iterable)) {
        throw new TypeError("'iterable' must be type of AsyncIterable");
    }
    var iterator = iterable[Symbol.asyncIterator]();
    var buffer = [];
    var prev = Promise.resolve();
    var nextCallCount = 0;
    var resolvedItemCount = 0;
    var finished = false;
    var pending = false;
    var settlementQueue = [];
    var consumeBuffer = function () {
        while (buffer.length > 0 && nextCallCount > resolvedItemCount) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var p = buffer.shift();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var _a = __read(settlementQueue.shift(), 2), resolve = _a[0], reject = _a[1];
            if (p.status === "fulfilled") {
                resolvedItemCount++;
                resolve(p.value);
                if (p.value.done) {
                    finished = true;
                }
            }
            else {
                reject(p.reason);
                finished = true;
                break;
            }
        }
    };
    var fillBuffer = function () {
        if (pending) {
            prev = prev.then(function () {
                return void (!finished && nextCallCount > resolvedItemCount && fillBuffer());
            });
        }
        else {
            var nextItems_1 = Promise.allSettled(Array.from({ length: length }, function () {
                return iterator.next(Concurrent.of(length));
            }));
            pending = true;
            prev = prev
                .then(function () { return nextItems_1; })
                .then(function (nextItems) {
                buffer.push.apply(buffer, __spreadArray([], __read(nextItems), false));
                pending = false;
                recur();
            });
        }
    };
    function recur() {
        if (finished || nextCallCount === resolvedItemCount) {
            return;
        }
        else if (buffer.length > 0) {
            consumeBuffer();
        }
        else {
            fillBuffer();
        }
    }
    return _a = {},
        _a[Symbol.asyncIterator] = function () {
            return this;
        },
        _a.next = function () {
            nextCallCount++;
            if (finished) {
                return { done: true, value: undefined };
            }
            return new Promise(function (resolve, reject) {
                settlementQueue.push([resolve, reject]);
                recur();
            });
        },
        _a;
}
export default concurrent;
//# sourceMappingURL=concurrent.js.map