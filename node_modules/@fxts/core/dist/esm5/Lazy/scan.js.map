{"version":3,"file":"scan.js","sourceRoot":"","sources":["../../../src/Lazy/scan.ts"],"names":[],"mappings":"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","sourcesContent":["import pipe1 from \"../pipe1\";\nimport Arrow from \"../types/Arrow\";\nimport Awaited from \"../types/Awaited\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { empty, isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\nimport head from \"../head\";\n\nfunction* sync<A, B>(\n  f: (a: B, b: A) => B,\n  acc: B,\n  iterable: Iterable<A>,\n): IterableIterator<B> {\n  yield acc;\n  for (const a of iterable) {\n    yield (acc = f(acc, a));\n  }\n}\n\nasync function* asyncSequential<A, B>(\n  f: (a: B, b: A) => B,\n  acc: Promise<B>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B> {\n  yield acc;\n  for await (const a of iterable) {\n    yield (acc = pipe1(acc, (acc) => f(acc as B, a)));\n  }\n}\n\nfunction async<A, B>(\n  f: (a: B, b: A) => B,\n  acc: Promise<B>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B> {\n  let _iterator: AsyncIterator<B>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(f, acc, concurrent(_concurrent.length, iterable))\n          : asyncSequential(f, acc, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\nfunction asyncWithoutSeed<A, B>(\n  f: (a: B, b: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B> {\n  let _iterator: AsyncIterator<B>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        if (isConcurrent(_concurrent)) {\n          const _iterable = concurrent(_concurrent.length, iterable);\n          _iterator = asyncSequential(f, head(_iterable) as any, _iterable);\n        } else {\n          _iterator = asyncSequential(f, head(iterable) as any, iterable);\n        }\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns a Iterable/AsyncIterable of successively reduced values from the left.\n * It's similar to reduce\n *\n * @example\n * ```ts\n * const iter = scan((acc, cur) => acc * cur, 1, [1, 2, 3, 4 ]);\n * iter.next(); // {value: 1, done:false}\n * iter.next(); // {value: 1, done:false}\n * iter.next(); // {value: 2, done:false}\n * iter.next(); // {value: 6, done:false}\n * iter.next(); // {value: 24, done:false}\n * iter.next(); // {value: undefined, done: true}\n *\n * // with pipe\n * pipe(\n *   [1, 2, 3, 4],\n *   scan((acc, cur) => acc * cur),\n *   toArray,\n * ); // [1, 2, 6, 24]\n * ```\n */\nfunction scan<A extends readonly []>(\n  f: Arrow,\n  iterable: A,\n): IterableIterator<never>;\n\nfunction scan<A extends readonly [], B>(\n  f: Arrow,\n  seed: B,\n  iterable: A,\n): IterableIterator<B>;\n\nfunction scan<A>(\n  f: (a: A, b: A) => A,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction scan<A, B>(\n  f: (a: B, b: A) => B,\n  seed: B,\n  iterable: Iterable<A>,\n): IterableIterator<B>;\n\nfunction scan<A, B>(\n  f: (a: B, b: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<B>;\n\nfunction scan<A>(\n  f: (a: A, b: A) => A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction scan<A, B>(\n  f: (a: Awaited<B>, b: A) => B | Promise<B>,\n  seed: B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B>;\n\nfunction scan<A, B>(\n  f: (a: Awaited<B>, b: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<Awaited<B>>;\n\nfunction scan<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (\n    a: IterableInfer<A>,\n    b: IterableInfer<A>,\n  ) => IterableInfer<A> | Promise<IterableInfer<A>>,\n): (iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>;\n\nfunction scan<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: B, b: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnIterableIteratorType<A, B>;\n\nfunction scan<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: B, b: IterableInfer<A>) => B,\n  seed?: B | Iterable<IterableInfer<A>> | AsyncIterable<IterableInfer<A>>,\n  iterable?: Iterable<IterableInfer<A>> | AsyncIterable<IterableInfer<A>>,\n):\n  | IterableIterator<B>\n  | AsyncIterableIterator<B>\n  | ((iterable: A) => ReturnIterableIteratorType<A, B>) {\n  if (iterable === undefined) {\n    if (seed === undefined) {\n      return (iterable: A) => {\n        return scan(\n          f,\n          iterable as any,\n        ) as unknown as ReturnIterableIteratorType<A, B>;\n      };\n    }\n\n    if (isIterable(seed)) {\n      const iterator = seed[Symbol.iterator]();\n      const { done, value } = iterator.next();\n      if (done) {\n        return empty() as IterableIterator<B>;\n      }\n\n      return sync(f, value as B, {\n        [Symbol.iterator]() {\n          return iterator;\n        },\n      });\n    }\n\n    if (isAsyncIterable(seed)) {\n      return asyncWithoutSeed(f, seed);\n    }\n\n    throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n  }\n\n  if (isIterable(iterable)) {\n    return sync(f, seed as B, iterable);\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(f, Promise.resolve(seed as B), iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default scan;\n"]}