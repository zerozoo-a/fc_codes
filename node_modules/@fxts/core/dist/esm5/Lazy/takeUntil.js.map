{"version":3,"file":"takeUntil.js","sourceRoot":"","sources":["../../../src/Lazy/takeUntil.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { AsyncFunctionException } from \"../_internal/error\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\n\nfunction* sync<A, B>(f: (a: A) => B, iterable: Iterable<A>) {\n  for (const item of iterable) {\n    yield item;\n\n    const res = f(item);\n    if (isPromise(res)) {\n      throw new AsyncFunctionException();\n    }\n\n    if (res) {\n      break;\n    }\n  }\n}\n\nfunction asyncSequential<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let end = false;\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(_concurrent) {\n      if (end) {\n        return { done: true, value: undefined };\n      }\n\n      const { done, value } = await iterator.next(_concurrent);\n      if (done || end) {\n        return { done: true, value: undefined };\n      }\n\n      const cond = await f(value);\n      if (end) {\n        return { done: true, value: undefined };\n      }\n\n      if (cond) {\n        end = true;\n      }\n\n      return { done: false, value };\n    },\n  };\n}\n\nfunction async<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let _iterator: AsyncIterator<A>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(f, concurrent(_concurrent.length, iterable))\n          : asyncSequential(f, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable that taken values until truthy when given `f` is applied.\n *\n * @example\n * ```ts\n * const iter = takeUntil(a => a % 2 === 0, [1, 2, 3, 4, 5, 6]);\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4, 5, 6],\n *  takeUntil(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 2]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4, 5, 6]),\n *  takeUntil(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 2]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4, 5, 6]),\n *  toAsync,\n *  takeUntil(async (a) => a % 2 === 0),\n *  toArray,\n * ); // [1, 2]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3),\n * Promise.resolve(4), Promise.resolve(5), Promise.resolve(6)],\n *  toAsync,\n *  takeUntil(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 2]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-takeuntil-gv1jk | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction takeUntil<A, B>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction takeUntil<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction takeUntil<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnIterableIteratorType<A>;\n\nfunction takeUntil<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: A) => B,\n  iterable?: Iterable<A> | AsyncIterable<A>,\n):\n  | IterableIterator<IterableInfer<A>>\n  | AsyncIterableIterator<IterableInfer<A>>\n  | ((iterable: A) => ReturnIterableIteratorType<A>) {\n  if (iterable === undefined) {\n    return (iterable: A) => {\n      return takeUntil(f, iterable as any) as ReturnIterableIteratorType<A>;\n    };\n  }\n\n  if (isIterable(iterable)) {\n    return sync(f, iterable) as IterableIterator<IterableInfer<A>>;\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(f, iterable) as AsyncIterableIterator<IterableInfer<A>>;\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default takeUntil;\n"]}