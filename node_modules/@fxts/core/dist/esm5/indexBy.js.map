{"version":3,"file":"indexBy.js","sourceRoot":"","sources":["../../src/indexBy.ts"],"names":[],"mappings":";AAGA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AA0C3D,SAAS,OAAO,CAId,CAA0C,EAC1C,QAAY;IALd,iBAgDC;IAtCC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UACL,QAAW;YAEX,OAAO,OAAO,CAAC,CAAC,EAAE,QAAe,CAGhC,CAAC;QACJ,CAAC,CAAC;KACH;IAED,IAAM,GAAG,GAAG,EAAoC,CAAC;IACjD,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CACX,UAAC,KAAK,EAAE,CAAC;YACP,IAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC;QACjC,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CACX,UAAO,KAAK,EAAE,CAAC;;;;4BACD,qBAAM,CAAC,CAAC,CAAC,CAAC,EAAA;;wBAAhB,GAAG,GAAG,SAAU;wBACtB,sBAAO,CAAA,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAA,EAAC;;;aAChC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import Key from \"./types/Key\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport IterableInfer from \"./types/IterableInfer\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport reduce from \"./reduce\";\nimport { AsyncFunctionException } from \"./_internal/error\";\n\n/**\n * Given `f` that generates a key,\n * turns a list of objects into an object indexing the objects by the given key.\n * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.\n *\n * @example\n * ```ts\n * const given = [\n *   { category: \"clothes\", desc: \"good\" },\n *   { category: \"pants\", desc: \"bad\" },\n *   { category: \"shoes\", desc: \"not bad\" },\n * ];\n *\n * indexBy(a => a.category, given);\n * // {\n * //   clothes: { category: \"clothes\", desc: \"good\" },\n * //   pants: { category: \"pants\", desc: \"bad\" },\n * //   shoes: { category: \"shoes\", desc: \"not bad\" },\n * // };\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-indexby-zpeok | Try It}\n */\nfunction indexBy<A, B extends Key>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): { [K in B]: A };\n\nfunction indexBy<A, B extends Key>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in B]: A }>;\n\nfunction indexBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A> }>;\n\nfunction indexBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n  iterable?: A,\n):\n  | { [K in B]: IterableInfer<A> }\n  | Promise<{ [K in B]: IterableInfer<A> }>\n  | ((iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A> }>) {\n  if (iterable === undefined) {\n    return (\n      iterable: A,\n    ): ReturnValueType<A, { [K in B]: IterableInfer<A> }> => {\n      return indexBy(f, iterable as any) as ReturnValueType<\n        A,\n        { [K in B]: IterableInfer<A> }\n      >;\n    };\n  }\n\n  const obj = {} as { [K in B]: IterableInfer<A> };\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      (group, a) => {\n        const key = f(a);\n        if (isPromise(key)) {\n          throw new AsyncFunctionException();\n        }\n        return (group[key] = a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      async (group, a) => {\n        const key = await f(a);\n        return (group[key] = a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default indexBy;\n"]}