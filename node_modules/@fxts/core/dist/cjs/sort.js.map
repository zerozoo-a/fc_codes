{"version":3,"file":"sort.js","sourceRoot":"","sources":["../../src/sort.ts"],"names":[],"mappings":";;;AAEA,2CAAgE;AAChE,8DAAgC;AAChC,0DAA4B;AAC5B,8DAAgC;AAgChC,SAAS,IAAI,CACX,CAAwD,EACxD,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAe,CAA2C,CAAC;QAC5E,CAAC,CAAC;KACH;IAED,IAAI,IAAA,iBAAO,EAAC,QAAQ,CAAC,EAAE;QACrB,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAQ,CAAC,CAAC;KAChC;IAED,IAAI,IAAA,kBAAU,EAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAA,eAAK,EAAC,IAAA,iBAAO,EAAC,QAAsC,CAAC,EAAE,UAAC,GAAG;YAChE,OAAA,GAAG,CAAC,IAAI,CAAC,CAAQ,CAAC;QAAlB,CAAkB,CACnB,CAAC;KACH;IAED,IAAI,IAAA,uBAAe,EAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,IAAA,eAAK,EAAC,IAAA,iBAAO,EAAC,QAA2C,CAAC,EAAE,UAAC,GAAG;YACrE,OAAA,GAAG,CAAC,IAAI,CAAC,CAAQ,CAAC;QAAlB,CAAkB,CACnB,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,IAAI,CAAC","sourcesContent":["import IterableInfer from \"./types/IterableInfer\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport { isAsyncIterable, isIterable } from \"./_internal/utils\";\nimport isArray from \"./isArray\";\nimport pipe1 from \"./pipe1\";\nimport toArray from \"./toArray\";\n\n/**\n * Returns an array, sorted according to the comparator `f`, which should accept two values\n *\n * @example\n * ```ts\n * sort((a, b) => a > b, [3, 4, 1, 2, 5, 2]); // [1, 2, 2, 3, 4, 5]\n * sort((a, b) => a > b, 'bcdaef); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n * ```\n */\n// prettier-ignore\nfunction sort(\n    f: (a: any, b: any) => unknown,\n    iterable: readonly []\n): any[];\n\n// prettier-ignore\nfunction sort<T>(\n  f: (a: T, b: T) => unknown,\n  iterable: Iterable<T>\n): T[];\n\nfunction sort<T>(\n  f: (a: T, b: T) => unknown,\n  iterable: AsyncIterable<T>,\n): Promise<T[]>;\n\nfunction sort<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>, b: IterableInfer<T>) => unknown,\n): (iterable: T) => ReturnValueType<T, IterableInfer<T>[]>;\n\nfunction sort<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: IterableInfer<T>, b: IterableInfer<T>) => unknown,\n  iterable?: T,\n):\n  | IterableInfer<T>[]\n  | Promise<IterableInfer<T>[]>\n  | ((iterable: T) => ReturnValueType<T, IterableInfer<T>[]>) {\n  if (iterable === undefined) {\n    return (iterable: T) => {\n      return sort(f, iterable as any) as ReturnValueType<T, IterableInfer<T>[]>;\n    };\n  }\n\n  if (isArray(iterable)) {\n    return iterable.sort(f as any);\n  }\n\n  if (isIterable(iterable)) {\n    return pipe1(toArray(iterable as Iterable<IterableInfer<T>>), (arr) =>\n      arr.sort(f as any),\n    );\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return pipe1(toArray(iterable as AsyncIterable<IterableInfer<T>>), (arr) =>\n      arr.sort(f as any),\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default sort;\n"]}