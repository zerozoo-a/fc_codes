{"version":3,"file":"each.js","sourceRoot":"","sources":["../../src/each.ts"],"names":[],"mappings":";;;AAEA,2CAA2E;AAE3E,SAAS,IAAI,CAAiB,CAAc,EAAE,QAAqB;;;QACjE,KAAgB,IAAA,aAAA,iBAAA,QAAQ,CAAA,kCAAA,wDAAE;YAArB,IAAM,CAAC,qBAAA;YACV,CAAC,CAAC,CAAC,CAAC,CAAC;SACN;;;;;;;;;AACH,CAAC;AAED,SAAe,KAAK,CAClB,CAAc,EACd,QAA0B;;;;;;;;;oBAED,aAAA,sBAAA,QAAQ,CAAA;;;;;oBAAhB,IAAI,qBAAA,CAAA;oBACb,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;yBAClB,IAAA,iBAAS,EAAC,KAAK,CAAC,EAAhB,wBAAgB;oBAClB,qBAAM,KAAK,EAAA;;oBAAX,SAAW,CAAC;;;;;;;;;;;;;;;;;;;;;;;;CAGjB;AA4BD,SAAS,IAAI,CACX,CAA6B,EAC7B,QAAY;IAEZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAe,CAA6B,CAAC;QAC9D,CAAC,CAAC;KACH;IAED,IAAI,IAAA,kBAAU,EAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,IAAI,IAAA,uBAAe,EAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC3B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,IAAI,CAAC","sourcesContent":["import IterableInfer from \"./types/IterableInfer\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\n\nfunction sync<A, B = unknown>(f: (a: A) => B, iterable: Iterable<A>): void {\n  for (const a of iterable) {\n    f(a);\n  }\n}\n\nasync function async<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<void> {\n  for await (const item of iterable) {\n    const value = f(item);\n    if (isPromise(value)) {\n      await value;\n    }\n  }\n}\n\n/**\n * Iterates over Iterable/AsyncIterable, applying each in turn to `f`.\n *\n * @example\n * ```ts\n * each(console.log, [1, 2, 3]); // log 1, 2, 3\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-each-kvz6w | Try It}\n */\n// prettier-ignore\nfunction each<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>\n): void;\n\nfunction each<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<void>;\n\nfunction each<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(f: (a: IterableInfer<A>) => B): (iterable: A) => ReturnValueType<A, void>;\n\nfunction each<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): void | Promise<void> | ((iterable: A) => ReturnValueType<A, void>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnValueType<A, void> => {\n      return each(f, iterable as any) as ReturnValueType<A, void>;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return sync(f, iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return async(f, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default each;\n"]}