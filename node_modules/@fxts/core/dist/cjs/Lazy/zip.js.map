{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../../src/Lazy/zip.ts"],"names":[],"mappings":"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","sourcesContent":["import map from \"./map\";\nimport pipe from \"../pipe\";\nimport toArray from \"../toArray\";\nimport toAsync from \"./toAsync\";\nimport { isAsyncIterable, isIterable, toIterator } from \"../_internal/utils\";\nimport ReturnZipType from \"../types/ReturnZipType\";\nimport range from \"./range\";\nimport takeWhile from \"./takeWhile\";\nimport every from \"../every\";\nimport { UniversalIterable } from \"../types/Utils\";\n\nfunction sync(\n  iterable: Iterable<Iterable<unknown>>,\n): IterableIterator<Iterable<unknown>> {\n  const iterators = toArray(\n    map((a) => toIterator(a), iterable as Iterable<Iterable<unknown>>),\n  );\n\n  return pipe(\n    range(Infinity),\n    map(() => toArray(map((it) => it.next(), iterators))),\n    takeWhile(every((cur2) => !cur2.done)),\n    map((cur1) => toArray(map((cur2) => cur2.value, cur1))),\n  );\n}\n\nfunction async(\n  iterable: Iterable<UniversalIterable>,\n): AsyncIterableIterator<UniversalIterable> {\n  const iterators = toArray(map(toIterator, iterable as any));\n\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(_concurrent) {\n      const headIterators = await pipe(\n        toAsync(iterators),\n        map((it) => it.next(_concurrent)),\n        toArray,\n      );\n\n      const hasDone = headIterators.some((it) => it.done);\n      if (hasDone) {\n        return { done: true, value: undefined };\n      }\n\n      return {\n        done: false,\n        value: headIterators.map((it) => it.value),\n      };\n    },\n  };\n}\n\n/**\n * Merges the values of each of the arrays with the values at the corresponding position together.\n * Useful when you have separate data sources that are coordinated through matching array indices.\n *\n * @example\n * ```ts\n * const iter = zip([1, 2, 3, 4], [5, 6, 7, 8]);\n * iter.next() // {done:false, value: [1, 5]}\n * iter.next() // {done:false, value: [2, 6]}\n * iter.next() // {done:false, value: [3, 7]}\n * iter.next() // {done:false, value: [4, 8]}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [5, 6, 7, 8],\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * ); // [[1, 5], [2, 6], [3, 7], [4, 8]]\n *\n * await pipe(\n *  Promise.resolve([5, 6, 7, 8]),\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(5), Promise.resolve(6), Promise.resolve(7), Promise.resolve(8)],\n *  toAsync,\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-zip-81jnh | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction zip<T extends UniversalIterable, TS extends UniversalIterable[]>(\n  a: T,\n): (...args: TS) => ReturnZipType<[T, ...TS]>;\n\n// prettier-ignore\nfunction zip<T extends UniversalIterable[]>(\n  ...args: T\n): ReturnZipType<[...T]>;\n\nfunction zip<TS extends UniversalIterable[]>(\n  ...iterables: TS[]\n): ReturnZipType<TS> | ((...iterables: TS[]) => ReturnZipType<TS>) {\n  if (iterables.length < 2) {\n    return (...iterables2: UniversalIterable[]) => {\n      return zip(...iterables, ...iterables2) as ReturnZipType<TS>;\n    };\n  }\n\n  if (iterables.some((a) => !isIterable(a) && !isAsyncIterable(a))) {\n    throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n  }\n\n  const hasAsyncIterable = iterables.some((iterable) =>\n    isAsyncIterable(iterable),\n  );\n\n  if (hasAsyncIterable) {\n    return async(iterables) as ReturnZipType<TS>;\n  }\n\n  return sync(iterables as Iterable<Iterable<unknown>>[]) as ReturnZipType<TS>;\n}\n\nexport default zip;\n"]}