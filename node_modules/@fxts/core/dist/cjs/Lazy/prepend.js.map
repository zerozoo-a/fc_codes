{"version":3,"file":"prepend.js","sourceRoot":"","sources":["../../../src/Lazy/prepend.ts"],"names":[],"mappings":";;;AAEA,4CAA4E;AAE5E,SAAU,IAAI,CAAI,CAAI,EAAE,QAAqB;;;oBAC3C,qBAAM,CAAC,EAAA;;gBAAP,SAAO,CAAC;gBACR,sBAAA,iBAAO,QAAQ,CAAA,EAAA;;gBAAf,SAAe,CAAC;;;;CACjB;AAED,SAAS,KAAK,CACZ,CAAa,EACb,QAA0B;;IAE1B,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAClD;QACE,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;QACK,OAAI,GAAV,UAAW,UAAU;;;;;;iCACf,WAAW,EAAX,wBAAW;4BACb,WAAW,GAAG,KAAK,CAAC;mCACX,IAAI,EAAE,KAAK;4BAAS,qBAAM,CAAC,EAAA;gCAApC,uBAAsB,QAAK,GAAE,SAAO,OAAG;gCAEzC,sBAAO,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,EAAC;;;;SAClC;WACD;AACJ,CAAC;AAoDD,SAAS,OAAO,CACd,CAAI,EACJ,QAAyC;IAKzC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAA,OAAO,CAAC,CAAC,EAAE,QAAe,CAA4B;QAAtD,CAAsD,CAAC;KAC1D;IAED,IAAI,IAAA,uBAAe,EAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC,IAAA,iBAAS,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC/D;IAED,IAAI,IAAA,kBAAU,EAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,OAAO,CAAC","sourcesContent":["import Awaited from \"../types/Awaited\";\nimport ReturnPrependType from \"../types/ReturnPrependType\";\nimport { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\n\nfunction* sync<A>(a: A, iterable: Iterable<A>): IterableIterator<A> {\n  yield a;\n  yield* iterable;\n}\n\nfunction async<A>(\n  a: Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let isFirstItem = true;\n  const iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(concurrent) {\n      if (isFirstItem) {\n        isFirstItem = false;\n        return { done: false, value: await a };\n      }\n      return iterator.next(concurrent);\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable with the given element at the front,\n * followed by the contents of iterable.\n *\n * @example\n * ```ts\n * const iter = prepend(4, [1, 2, 3]);\n * iter.next() // {done:false, value: 4}\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:false, value: 3}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3],\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3]),\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n *  toAsync,\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-prepend-70ymx | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction prepend<A>(a: A, iterable: Iterable<A>): IterableIterator<A>;\n\nfunction prepend<A, B extends Iterable<A> | AsyncIterable<Awaited<A>>>(\n  a: A,\n): (iterable: B) => ReturnPrependType<A, B>;\n\nfunction prepend<A>(\n  a: A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction prepend<A, B extends Iterable<A> | AsyncIterable<Awaited<A>>>(\n  a: A,\n  iterable?: Iterable<A> | AsyncIterable<A>,\n):\n  | IterableIterator<A>\n  | AsyncIterableIterator<A>\n  | ((iterable: B) => ReturnPrependType<A, B>) {\n  if (iterable === undefined) {\n    return (iterable: B) =>\n      prepend(a, iterable as any) as ReturnPrependType<A, B>;\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(isPromise(a) ? a : Promise.resolve(a), iterable);\n  }\n\n  if (isIterable(iterable)) {\n    return sync(a, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default prepend;\n"]}