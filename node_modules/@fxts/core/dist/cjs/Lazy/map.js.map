{"version":3,"file":"map.js","sourceRoot":"","sources":["../../../src/Lazy/map.ts"],"names":[],"mappings":";;;AAAA,4CAA4E;AAI5E,4CAA4D;AAE5D,SAAS,IAAI,CACX,CAAc,EACd,QAAqB;;IAErB,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IAE7C;YACE,IAAI;gBACI,IAAA,KAAkB,QAAQ,CAAC,IAAI,EAAE,EAA/B,IAAI,UAAA,EAAE,KAAK,WAAoB,CAAC;gBACxC,IAAI,IAAI,EAAE;oBACR,OAAO;wBACL,IAAI,EAAE,IAAI;wBACV,KAAK,EAAE,SAAS;qBACjB,CAAC;iBACH;gBAED,IAAM,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;gBACrB,IAAI,IAAA,iBAAS,EAAC,GAAG,CAAC,EAAE;oBAClB,MAAM,IAAI,8BAAsB,EAAE,CAAC;iBACpC;gBAED,OAAO;oBACL,IAAI,EAAE,KAAK;oBACX,KAAK,EAAE,GAAG;iBACX,CAAC;YACJ,CAAC;;QACD,GAAC,MAAM,CAAC,QAAQ,IAAhB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;WACD;AACJ,CAAC;AAED,SAAS,KAAK,CACZ,CAAc,EACd,QAA0B;;IAE1B,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAElD;YACQ,IAAI,EAAV,UAAW,WAAW;;;;;;oCACI,qBAAM,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAA;;gCAAlD,KAAkB,SAAgC,EAAhD,IAAI,UAAA,EAAE,KAAK,WAAA;gCACnB,IAAI,IAAI;oCAAE,sBAAO,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAgC,EAAC;;oCAE7D,IAAI,EAAE,KAAK;;gCACJ,qBAAM,CAAC,CAAC,KAAK,CAAC,EAAA;oCAFvB,uBAEE,QAAK,GAAE,SAAc;yCACrB;;;;aACH;;QACD,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;WACD;AACJ,CAAC;AAgED,SAAS,GAAG,CACV,CAA6B,EAC7B,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,GAAG,CAAC,CAAC,EAAE,QAAe,CAAqC,CAAC;QACrE,CAAC,CAAC;KACH;IAED,IAAI,IAAA,kBAAU,EAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,IAAI,IAAA,uBAAe,EAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC3B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,GAAG,CAAC","sourcesContent":["import { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\nimport Awaited from \"../types/Awaited\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { AsyncFunctionException } from \"../_internal/error\";\n\nfunction sync<A, B>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<B> {\n  const iterator = iterable[Symbol.iterator]();\n\n  return {\n    next() {\n      const { done, value } = iterator.next();\n      if (done) {\n        return {\n          done: true,\n          value: undefined,\n        };\n      }\n\n      const res = f(value);\n      if (isPromise(res)) {\n        throw new AsyncFunctionException();\n      }\n\n      return {\n        done: false,\n        value: res,\n      };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nfunction async<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  return {\n    async next(_concurrent) {\n      const { done, value } = await iterator.next(_concurrent);\n      if (done) return { done, value } as IteratorReturnResult<void>;\n      return {\n        done: false,\n        value: await f(value),\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable of values by running each applying `f`.\n *\n * @example\n * ```ts\n * const iter = map(a => a + 10, [1, 2, 3, 4]);\n * iter.next() // {done:false, value: 11}\n * iter.next() // {done:false, value: 12}\n * iter.next() // {done:false, value: 13}\n * iter.next() // {done:false, value: 14},\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4],\n *  map(a => a + 10),\n *  toArray,\n * ); // [11, 12, 13, 14]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  map(a => a + 10),\n *  toArray,\n * ); // [11, 12, 13, 14]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  toAsync,\n *  map(async (a) => a + 10),\n *  toArray,\n * ); // [11, 12, 13, 14]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  map(a => a + 10),\n *  toArray,\n * ); // [11, 12, 13, 14]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-map-j68jv | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\n// prettier-ignore\nfunction map<A, B>(\n  f: (a: A) => B,\n  iterable: Iterable<A>\n): IterableIterator<B>;\n\nfunction map<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<Awaited<B>>;\n\nfunction map<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnIterableIteratorType<A, B>;\n\nfunction map<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | IterableIterator<B>\n  | AsyncIterableIterator<B>\n  | ((iterable: A) => ReturnIterableIteratorType<A, B>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnIterableIteratorType<A, B> => {\n      return map(f, iterable as any) as ReturnIterableIteratorType<A, B>;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return sync(f, iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return async(f, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default map;\n"]}