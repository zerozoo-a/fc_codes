{"version":3,"file":"zipWith.js","sourceRoot":"","sources":["../../../src/Lazy/zipWith.ts"],"names":[],"mappings":";;;AAAA,4CAAiE;AACjE,sDAAwB;AACxB,sDAAwB;AAsCxB,SAAS,OAAO,CACd,CAAoB,EACpB,SAAyC,EACzC,SAAyC;IAEzC,IAAI,IAAA,kBAAU,EAAC,SAAS,CAAC,IAAI,IAAA,kBAAU,EAAC,SAAS,CAAC,EAAE;QAClD,OAAO,IAAA,aAAG,EAAC,UAAC,EAAM;gBAAN,KAAA,qBAAM,EAAL,CAAC,QAAA,EAAE,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAAP,CAAO,EAAE,IAAA,aAAG,EAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;KAC5D;IACD,IAAI,IAAA,kBAAU,EAAC,SAAS,CAAC,IAAI,IAAA,uBAAe,EAAC,SAAS,CAAC,EAAE;QACvD,OAAO,IAAA,aAAG,EAAC,UAAC,EAAM;gBAAN,KAAA,qBAAM,EAAL,CAAC,QAAA,EAAE,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAAP,CAAO,EAAE,IAAA,aAAG,EAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;KAC5D;IACD,IAAI,IAAA,uBAAe,EAAC,SAAS,CAAC,IAAI,IAAA,kBAAU,EAAC,SAAS,CAAC,EAAE;QACvD,OAAO,IAAA,aAAG,EAAC,UAAC,EAAM;gBAAN,KAAA,qBAAM,EAAL,CAAC,QAAA,EAAE,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAAP,CAAO,EAAE,IAAA,aAAG,EAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;KAC5D;IACD,IAAI,IAAA,uBAAe,EAAC,SAAS,CAAC,IAAI,IAAA,uBAAe,EAAC,SAAS,CAAC,EAAE;QAC5D,OAAO,IAAA,aAAG,EAAC,UAAC,EAAM;gBAAN,KAAA,qBAAM,EAAL,CAAC,QAAA,EAAE,CAAC,QAAA;YAAM,OAAA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAAP,CAAO,EAAE,IAAA,aAAG,EAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;KAC5D;IAED,MAAM,IAAI,SAAS,CACjB,uEAAuE,CACxE,CAAC;AACJ,CAAC;AAED,kBAAe,OAAO,CAAC","sourcesContent":["import { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport map from \"./map\";\nimport zip from \"./zip\";\n\n/**\n * Returns Iterable/AsyncIterable out of the two supplied by applying `f` to each same positioned pair in Iterable/AsyncIterable.\n *\n * @example\n * ```ts\n * const iter = zipWith((a,b) => [a,b], [1,2,3], ['a','b','c']);\n * iter.next(); // {value: [1, 'a'] , done: false}\n * iter.next(); // {value: [2, 'b'] , done: false}\n * iter.next(); // {value: [3, 'c'] , done: false}\n * iter.next(); // {value: undefined , done: true}\n * ```\n */\nfunction zipWith<A, B, C>(\n  f: (a: A, b: B) => C,\n  iterable1: Iterable<A>,\n  iterable2: Iterable<B>,\n): IterableIterator<C>;\n\nfunction zipWith<A, B, C>(\n  f: (a: A, b: B) => C,\n  iterable1: Iterable<A>,\n  iterable2: AsyncIterable<B>,\n): AsyncIterableIterator<C>;\n\nfunction zipWith<A, B, C>(\n  f: (a: A, b: B) => C,\n  iterable1: AsyncIterable<A>,\n  iterable2: Iterable<B>,\n): AsyncIterableIterator<C>;\n\nfunction zipWith<A, B, C>(\n  f: (a: A, b: B) => C,\n  iterable1: AsyncIterable<A>,\n  iterable2: AsyncIterable<B>,\n): AsyncIterableIterator<C>;\n\nfunction zipWith<A, B, C>(\n  f: (a: A, b: B) => C,\n  iterable1: Iterable<A> | AsyncIterable<A>,\n  iterable2: Iterable<B> | AsyncIterable<B>,\n): IterableIterator<C> | AsyncIterableIterator<C> {\n  if (isIterable(iterable1) && isIterable(iterable2)) {\n    return map(([a, b]) => f(a, b), zip(iterable1, iterable2));\n  }\n  if (isIterable(iterable1) && isAsyncIterable(iterable2)) {\n    return map(([a, b]) => f(a, b), zip(iterable1, iterable2));\n  }\n  if (isAsyncIterable(iterable1) && isIterable(iterable2)) {\n    return map(([a, b]) => f(a, b), zip(iterable1, iterable2));\n  }\n  if (isAsyncIterable(iterable1) && isAsyncIterable(iterable2)) {\n    return map(([a, b]) => f(a, b), zip(iterable1, iterable2));\n  }\n\n  throw new TypeError(\n    \"'iterable1' and 'iterable2' must be type of Iterable or AsyncIterable\",\n  );\n}\n\nexport default zipWith;\n"]}