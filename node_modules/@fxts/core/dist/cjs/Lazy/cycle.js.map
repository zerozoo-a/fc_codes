{"version":3,"file":"cycle.js","sourceRoot":"","sources":["../../../src/Lazy/cycle.ts"],"names":[],"mappings":";;;AAEA,4CAAiE;AACjE,iEAAwD;AAExD,SAAU,IAAI,CAAI,QAAqB;;;;;;gBAC/B,GAAG,GAAG,EAAE,CAAC;;;;gBACC,aAAA,iBAAA,QAAQ,CAAA;;;;gBAAb,CAAC;gBACV,qBAAM,CAAC,EAAA;;gBAAP,SAAO,CAAC;gBACR,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;;;;;;;;;;;;;;;;qBAGP,GAAG,CAAC,MAAM;;;;gBACC,uBAAA,iBAAA,GAAG,CAAA,CAAA;;;;gBAAR,CAAC;gBACV,qBAAM,CAAC,EAAA;;gBAAP,SAAO,CAAC;;;;;;;;;;;;;;;;;;;;CAGb;AAED,SAAgB,eAAe,CAC7B,QAA0B;;;;;;;;oBAEpB,GAAG,GAAG,EAAE,CAAC;;;;oBACO,aAAA,sBAAA,QAAQ,CAAA;;;;;oBAAb,CAAC,qBAAA,CAAA;yDACV,CAAC;wBAAP,gCAAO;;oBAAP,SAAO,CAAC;oBACR,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;yBAGP,GAAG,CAAC,MAAM;;;;oBACC,uBAAA,iBAAA,GAAG,CAAA,CAAA;;;;oBAAR,CAAC;yDACJ,CAAC;yBAAP,gCAAO;;oBAAP,SAAO,CAAC;;;;;;;;;;;;;;;;;;;;;CAGb;AAED,SAAS,KAAK,CAAI,QAA0B;;IAC1C,IAAI,SAA2B,CAAC;IAChC;YACQ,IAAI,EAAV,UAAW,WAAgB;;;wBACzB,IAAI,SAAS,KAAK,SAAS,EAAE;4BAC3B,SAAS,GAAG,IAAA,yBAAY,EAAC,WAAW,CAAC;gCACnC,CAAC,CAAC,eAAe,CAAC,IAAA,oBAAU,EAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gCAC3D,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;yBAC/B;wBACD,sBAAO,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,EAAC;;;aACpC;;QACD,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;WACD;AACJ,CAAC;AA0BD,SAAS,KAAK,CACZ,QAAW;IAIX,IAAI,IAAA,kBAAU,EAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;KACvB;IACD,IAAI,IAAA,uBAAe,EAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC;KACxB;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,KAAK,CAAC","sourcesContent":["import IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\n\nfunction* sync<T>(iterable: Iterable<T>): IterableIterator<T> {\n  const arr = [];\n  for (const a of iterable) {\n    yield a;\n    arr.push(a);\n  }\n\n  while (arr.length) {\n    for (const a of arr) {\n      yield a;\n    }\n  }\n}\n\nasync function* asyncSequential<T>(\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T> {\n  const arr = [];\n  for await (const a of iterable) {\n    yield a;\n    arr.push(a);\n  }\n\n  while (arr.length) {\n    for (const a of arr) {\n      yield a;\n    }\n  }\n}\n\nfunction async<T>(iterable: AsyncIterable<T>): AsyncIterableIterator<T> {\n  let _iterator: AsyncIterator<T>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(concurrent(_concurrent.length, iterable))\n          : asyncSequential(iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable that infinitely repeats the given Iterable/AsyncIterable\n *\n * @example\n * ```ts\n * const iter = cycle(\"abc\")\n * iter.next(); // {value:\"a\", done: false}\n * iter.next(); // {value:\"b\", done: false}\n * iter.next(); // {value:\"c\", done: false}\n * iter.next(); // {value:\"a\", done: false}\n * iter.next(); // {value:\"b\", done: false}\n *\n * // with pipe\n * pipe(\n *   cycle([1,2,3,4]),\n *   take(5),\n *   toArray,\n * ); // [1,2,3,4,1]\n * ```\n */\nfunction cycle<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iter: A,\n): ReturnIterableIteratorType<A>;\n\nfunction cycle<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iterable: T,\n):\n  | IterableIterator<IterableInfer<T>>\n  | AsyncIterableIterator<IterableInfer<T>> {\n  if (isIterable<IterableInfer<T>>(iterable)) {\n    return sync(iterable);\n  }\n  if (isAsyncIterable<IterableInfer<T>>(iterable)) {\n    return async(iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default cycle;\n"]}