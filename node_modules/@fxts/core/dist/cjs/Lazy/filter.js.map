{"version":3,"file":"filter.js","sourceRoot":"","sources":["../../../src/Lazy/filter.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\nimport concurrent, { Concurrent, isConcurrent } from \"./concurrent\";\nimport pipe1 from \"../pipe1\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport TruthyTypesOf from \"../types/TrutyTypesOf\";\nimport { Reject, Resolve } from \"../types/Utils\";\nimport { AsyncFunctionException } from \"../_internal/error\";\n\nasync function* asyncSequential<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  for await (const item of iterable) {\n    if (await f(item)) yield item;\n  }\n}\n\nfunction asyncConcurrent<A>(\n  iterable: AsyncIterable<[boolean, A]>,\n): AsyncIterableIterator<A> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  const settlementQueue: [Resolve<A>, Reject][] = [] as unknown as [\n    Resolve<A>,\n    Reject,\n  ][];\n  const buffer: A[] = [];\n  let finished = false;\n  let nextCallCount = 0;\n  let resolvedCount = 0;\n  let prevItem = Promise.resolve();\n\n  function fillBuffer(concurrent: Concurrent) {\n    const nextItem = iterator.next(concurrent as any);\n    prevItem = prevItem\n      .then(() => nextItem)\n      .then(({ done, value }) => {\n        if (done) {\n          while (settlementQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [resolve] = settlementQueue.shift()!;\n            resolve({ done: true, value: undefined });\n          }\n          return void (finished = true);\n        }\n\n        const [cond, item] = value;\n        if (cond) {\n          buffer.push(item);\n        }\n        recur(concurrent);\n      })\n\n      .catch((reason: any) => {\n        finished = true;\n        while (settlementQueue.length > 0) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const [, reject] = settlementQueue.shift()!;\n          reject(reason);\n        }\n      });\n  }\n\n  function consumeBuffer() {\n    while (buffer.length > 0 && nextCallCount > resolvedCount) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const value = buffer.shift()!;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [resolve] = settlementQueue.shift()!;\n      resolve({ done: false, value });\n      resolvedCount++;\n    }\n  }\n\n  function recur(concurrent: Concurrent) {\n    if (finished || nextCallCount === resolvedCount) {\n      return;\n    } else if (buffer.length > 0) {\n      consumeBuffer();\n    } else {\n      fillBuffer(concurrent);\n    }\n  }\n\n  return {\n    async next(concurrent: any) {\n      nextCallCount++;\n      if (finished) {\n        return { done: true, value: undefined };\n      }\n      return new Promise((resolve, reject) => {\n        settlementQueue.push([resolve, reject]);\n        recur(concurrent as Concurrent);\n      });\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\nfunction toFilterIterator<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<[boolean, A]> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(_concurrent) {\n      const { done, value } = await iterator.next(_concurrent);\n      if (done) {\n        return {\n          done: true,\n          value: undefined,\n        } as IteratorReturnResult<undefined>;\n      }\n\n      return pipe1(\n        f(value),\n        (cond) =>\n          ({\n            done,\n            value: [Boolean(cond), value],\n          } as IteratorYieldResult<[boolean, A]>),\n      );\n    },\n  };\n}\n\nfunction async<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let _iterator: AsyncIterator<A>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncConcurrent(\n              concurrent(_concurrent.length, toFilterIterator(f, iterable)),\n            )\n          : asyncSequential(f, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\nfunction* sync<A>(f: (a: A) => unknown, iterable: Iterable<A>) {\n  for (const a of iterable) {\n    const res = f(a);\n\n    if (isPromise(res)) {\n      throw new AsyncFunctionException();\n    }\n\n    if (res) {\n      yield a;\n    }\n  }\n}\n\n/**\n * Return Iterable/AsyncIterable of all elements `f` returns truthy for\n *\n * @example\n * ```ts\n * const iter = filter((a)=> a % 2 === 0, [0, 1, 2, 3, 4, 5, 6]);\n * iter.next() // {done:false, value: 0}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:false, value: 4}\n * iter.next() // {done:false, value: 6}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [0, 1, 2, 3, 4, 5, 6],\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  toAsync,\n *  filter(async a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * // toAsync\n * await pipe(\n *  [Promise.resolve(0), Promise.resolve(1), Promise.resolve(2), Promise.resolve(3),\n *   Promise.resolve(4), Promise.resolve(5), Promise.resolve(6)],\n *  toAsync,\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-filter-2ibz2 | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction filter<A>(\n  f: BooleanConstructor,\n  iterable: Iterable<A>,\n): IterableIterator<TruthyTypesOf<A>>;\n\nfunction filter<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: Iterable<A>,\n): IterableIterator<B>;\n\nfunction filter<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction filter<A>(\n  f: BooleanConstructor,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<TruthyTypesOf<A>>;\n\nfunction filter<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B>;\n\nfunction filter<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction filter<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: BooleanConstructor,\n): (\n  iterable: A,\n) => ReturnIterableIteratorType<A, TruthyTypesOf<IterableInfer<A>>>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends IterableInfer<A>,\n>(\n  f: (a: IterableInfer<A>) => a is B,\n): (iterable: A) => ReturnIterableIteratorType<A, B>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | IterableIterator<IterableInfer<A>>\n  | IterableIterator<TruthyTypesOf<IterableInfer<A>>>\n  | AsyncIterableIterator<IterableInfer<A>>\n  | AsyncIterableIterator<TruthyTypesOf<IterableInfer<A>>>\n  | ((iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>)\n  | ((\n      iterable: A,\n    ) => ReturnIterableIteratorType<A, TruthyTypesOf<IterableInfer<A>>>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnIterableIteratorType<A, IterableInfer<A>> =>\n      filter(f, iterable as any) as ReturnIterableIteratorType<\n        A,\n        IterableInfer<A>\n      >;\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return sync(f, iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return async(f, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default filter;\n"]}