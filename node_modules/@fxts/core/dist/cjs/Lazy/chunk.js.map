{"version":3,"file":"chunk.js","sourceRoot":"","sources":["../../../src/Lazy/chunk.ts"],"names":[],"mappings":";;;AAAA,wDAA0B;AAC1B,+DAAiC;AACjC,4CAK4B;AAG5B,iEAAwD;AAExD,SAAU,IAAI,CAAI,IAAY,EAAE,QAAqB;;;;;;gBAC7C,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;;;qBACtC,IAAI;gBACH,CAAC,GAAG,IAAA,iBAAO,EACf,IAAA,cAAI,EAAC,IAAI;oBACP,GAAC,MAAM,CAAC,QAAQ,IAAhB;wBACE,OAAO,QAAQ,CAAC;oBAClB,CAAC;wBACD,CACH,CAAC;qBACE,CAAA,CAAC,CAAC,MAAM,GAAG,CAAC,CAAA,EAAZ,wBAAY;gBAAE,qBAAM,CAAC,EAAA;;gBAAP,SAAO,CAAC;;;gBAC1B,IAAI,CAAC,CAAC,MAAM,GAAG,IAAI;oBAAE,sBAAO;;;;;CAE/B;AAED,SAAgB,eAAe,CAC7B,IAAY,EACZ,QAA0B;;;;;;;oBAEtB,CAAC,GAAG,CAAC,CAAC;oBACN,KAAK,GAAQ,EAAE,CAAC;;;;oBACK,aAAA,sBAAA,QAAQ,CAAA;;;;;oBAAhB,IAAI,qBAAA,CAAA;oBACnB,IAAI,CAAC,EAAE,GAAG,IAAI,EAAE;wBACd,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBAClB;yBACG,CAAA,CAAC,KAAK,IAAI,CAAA,EAAV,wBAAU;yDACN,KAAK;wBAAX,gCAAW;;oBAAX,SAAW,CAAC;oBACZ,CAAC,GAAG,CAAC,CAAC;oBACN,KAAK,GAAG,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;yBAGX,KAAK,CAAC,MAAM,EAAZ,yBAAY;yDACR,KAAK;yBAAX,gCAAW;;oBAAX,SAAW,CAAC;;;;;;CAEf;AAED,SAAS,KAAK,CACZ,IAAY,EACZ,QAA0B;;IAE1B,IAAI,SAA6B,CAAC;IAClC;YACQ,IAAI,EAAV,UAAW,WAAgB;;;wBACzB,IAAI,SAAS,KAAK,SAAS,EAAE;4BAC3B,SAAS,GAAG,IAAA,yBAAY,EAAC,WAAW,CAAC;gCACnC,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,IAAA,oBAAU,EAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gCACjE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;yBACrC;wBACD,sBAAO,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,EAAC;;;aACpC;;QACD,GAAC,MAAM,CAAC,aAAa,IAArB;YACE,OAAO,IAAI,CAAC;QACd,CAAC;WACD;AACJ,CAAC;AAkDD,SAAS,KAAK,CACZ,IAAY,EACZ,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAA,KAAK,CAAC,IAAI,EAAE,QAAe,CAG1B;QAHD,CAGC,CAAC;KACL;IAED,IAAI,IAAA,kBAAU,EAAC,QAAQ,CAAC,EAAE;QACxB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,OAAO,IAAA,aAAK,GAAE,CAAC;SAChB;aAAM;YACL,OAAO,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAyC,CAAC;SACrE;KACF;IAED,IAAI,IAAA,uBAAe,EAAC,QAAQ,CAAC,EAAE;QAC7B,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,OAAO,IAAA,kBAAU,GAAE,CAAC;SACrB;aAAM;YACL,OAAO,KAAK,CAAC,IAAI,EAAE,QAAQ,CAA8C,CAAC;SAC3E;KACF;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,KAAK,CAAC","sourcesContent":["import take from \"./take\";\nimport toArray from \"../toArray\";\nimport {\n  asyncEmpty,\n  empty,\n  isAsyncIterable,\n  isIterable,\n} from \"../_internal/utils\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\n\nfunction* sync<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]> {\n  const iterator = iterable[Symbol.iterator]();\n  while (true) {\n    const c = toArray(\n      take(size, {\n        [Symbol.iterator]() {\n          return iterator;\n        },\n      }),\n    );\n    if (c.length > 0) yield c;\n    if (c.length < size) return;\n  }\n}\n\nasync function* asyncSequential<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]> {\n  let i = 0;\n  let items: T[] = [];\n  for await (const item of iterable) {\n    if (i++ < size) {\n      items.push(item);\n    }\n    if (i === size) {\n      yield items;\n      i = 0;\n      items = [];\n    }\n  }\n  if (items.length) {\n    yield items;\n  }\n}\n\nfunction async<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]> {\n  let _iterator: AsyncIterator<T[]>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(size, concurrent(_concurrent.length, iterable))\n          : asyncSequential(size, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable of elements split into groups the length of size.\n * If iterableIterator can't be split evenly, the final chunk will be the remaining elements.\n *\n * @example\n * ```ts\n * const iter = chunk(2, [1, 2, 3, 4]);\n * iter.next() // {done:false, value:[1, 2]}\n * iter.next() // {done:false, value:[3, 4]}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4],\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3 ,4]),\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-chunk-gksly | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction chunk<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]>;\nfunction chunk<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]>;\n\nfunction chunk<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  size: number,\n): (iterable: T) => ReturnIterableIteratorType<T, IterableInfer<T>[]>;\n\nfunction chunk<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  size: number,\n  iterable?: T,\n):\n  | IterableIterator<IterableInfer<T>[]>\n  | AsyncIterableIterator<IterableInfer<T>[]>\n  | ((iterable: T) => ReturnIterableIteratorType<T, IterableInfer<T>[]>) {\n  if (iterable === undefined) {\n    return (iterable: T) =>\n      chunk(size, iterable as any) as ReturnIterableIteratorType<\n        T,\n        IterableInfer<T>[]\n      >;\n  }\n\n  if (isIterable(iterable)) {\n    if (size < 1) {\n      return empty();\n    } else {\n      return sync(size, iterable) as IterableIterator<IterableInfer<T>[]>;\n    }\n  }\n\n  if (isAsyncIterable(iterable)) {\n    if (size < 1) {\n      return asyncEmpty();\n    } else {\n      return async(size, iterable) as AsyncIterableIterator<IterableInfer<T>[]>;\n    }\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default chunk;\n"]}