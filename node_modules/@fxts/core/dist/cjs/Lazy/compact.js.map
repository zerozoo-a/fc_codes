{"version":3,"file":"compact.js","sourceRoot":"","sources":["../../../src/Lazy/compact.ts"],"names":[],"mappings":";;;AAEA,4CAAgF;AAChF,4DAA8B;AA6C9B,SAAS,OAAO,CACd,QAAW;IAEX,IAAI,IAAA,kBAAU,EAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAA,gBAAM,EAAC,qBAAa,EAAE,QAAQ,CAAC,CAAC;KACxC;IAED,IAAI,IAAA,uBAAe,EAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,IAAA,gBAAM,EAAC,qBAAa,EAAE,QAAQ,CAAC,CAAC;KACxC;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,OAAO,CAAC","sourcesContent":["import IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { isAsyncIterable, isIterable, isNotNullable } from \"../_internal/utils\";\nimport filter from \"./filter\";\n\n/**\n * Returns Iterable/AsyncIterable with all `null` and `undefined` values removed.\n *\n * @example\n * ```ts\n * const iter = compact([0, 1, undefined, 3, null]);\n * iter.next() // {done:false, value: 0}\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 3}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [0, 1, undefined, 3, null],\n *  compact,\n *  toArray,\n * ); // [0, 1, 3]\n *\n * await pipe(\n *  Promise.resolve([0, 1, undefined, 3, null]),\n *  compact,\n *  toArray,\n * ); // [0, 1, 3]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(0), Promise.resolve(1), Promise.resolve(undefined),\n *    Promise.resolve(3), Promise.resolve(null)],\n *  toAsync,\n *  compact,\n *  toArray,\n * ); // [0, 1, 3]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-compact-lnvmd | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction compact<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iterable: T,\n): ReturnIterableIteratorType<T, NonNullable<IterableInfer<T>>>;\n\nfunction compact<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iterable: T,\n) {\n  if (isIterable(iterable)) {\n    return filter(isNotNullable, iterable);\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return filter(isNotNullable, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default compact;\n"]}