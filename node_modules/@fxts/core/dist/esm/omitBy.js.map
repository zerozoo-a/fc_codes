{"version":3,"file":"omitBy.js","sourceRoot":"","sources":["../../src/omitBy.ts"],"names":[],"mappings":"AAKA,OAAO,OAAO,MAAM,WAAW,CAAC;AAChC,OAAO,MAAM,MAAM,eAAe,CAAC;AACnC,OAAO,OAAO,MAAM,gBAAgB,CAAC;AACrC,OAAO,GAAG,MAAM,YAAY,CAAC;AAC7B,OAAO,GAAG,MAAM,YAAY,CAAC;AAC7B,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAuD9C,SAAS,MAAM,CACb,CAAI,EACJ,GAAO;IAOP,IAAI,GAAG,KAAK,SAAS,EAAE;QACrB,OAAO,CAAC,GAAM,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;KACnC;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACpC,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,KAAY,CAAC,CAAC,CAAC;IAC3D,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAErD,IAAI,OAAO,EAAE;QACX,OAAO,IAAI,CACT,OAAO,EACP,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,EACxB,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,EACxB,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,EACzB,OAAO,EACP,MAAM,CAAC,WAAW,CACI,CAAC;KAC1B;SAAM;QACL,OAAO,IAAI,CACT,OAAO,EACP,GAAG,CAAC,UAAU,CAAC,EACf,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,EACxB,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,EACzB,MAAM,CAAC,WAAW,CACL,CAAC;KACjB;AACH,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import {\n  AsyncEntryPredicate,\n  ConditionalAsyncEntryPredicate,\n  EntryPredicate,\n} from \"./types/EntryPredicate\";\nimport toArray from \"./toArray\";\nimport reject from \"./Lazy/reject\";\nimport toAsync from \"./Lazy/toAsync\";\nimport map from \"./Lazy/map\";\nimport zip from \"./Lazy/zip\";\nimport pipe from \"./pipe\";\nimport { isPromise } from \"./_internal/utils\";\n\n/**\n *\n * Returns a partial copy of an object containing only the keys that satisfy the supplied predicate.\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"2\", c: true };\n * omitBy(([key, value]) => key === \"a\" || value === true, obj); // { b: \"2\" }\n *\n * // asynchronous predicate\n * await omitBy(async ([key, value]) => key === \"a\" || value === true, obj); // { b: \"2\" }\n *\n * // Using with the `pipe` function\n * pipe(\n *   obj,\n *   omitBy(([key, value]) => key === \"a\" || value === true)\n * );\n *\n * await pipe(\n *   obj,\n *   omitBy(async ([key, value]) => key === \"a\" || value === true)\n * );\n * ```\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/omit | omit},\n */\n\nfunction omitBy<T extends object, F extends AsyncEntryPredicate<T>>(\n  f: F,\n  obj: T,\n): Promise<Partial<T>>;\n\nfunction omitBy<T extends object, F extends AsyncEntryPredicate<T>>(\n  f: F,\n): (obj: T) => Promise<Partial<T>>;\n\nfunction omitBy<T extends object, F extends EntryPredicate<T>>(\n  f: F,\n  obj: T,\n): Partial<T>;\n\nfunction omitBy<T extends object, F extends EntryPredicate<T>>(\n  f: F,\n): (obj: T) => Partial<T>;\n\nfunction omitBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(\n  f: F,\n  obj: T,\n): Partial<T> | Promise<Partial<T>>;\n\nfunction omitBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(\n  f: F,\n): (obj: T) => Partial<T> | Promise<Partial<T>>;\n\nfunction omitBy<T extends object, F extends ConditionalAsyncEntryPredicate<T>>(\n  f: F,\n  obj?: T,\n):\n  | Partial<T>\n  | Promise<Partial<T>>\n  | ((obj: T) => Partial<T>)\n  | ((obj: T) => Promise<Partial<T>>)\n  | ((obj: T) => Partial<T> | Promise<Partial<T>>) {\n  if (obj === undefined) {\n    return (obj: T) => omitBy(f, obj);\n  }\n\n  const entries = Object.entries(obj);\n  const conditions = entries.map((entry) => f(entry as any));\n  const isAsync = conditions.some((c) => isPromise(c));\n\n  if (isAsync) {\n    return pipe(\n      entries,\n      zip(toAsync(conditions)),\n      reject(([cond]) => cond),\n      map(([, entry]) => entry),\n      toArray,\n      Object.fromEntries,\n    ) as Promise<Partial<T>>;\n  } else {\n    return pipe(\n      entries,\n      zip(conditions),\n      reject(([cond]) => cond),\n      map(([, entry]) => entry),\n      Object.fromEntries,\n    ) as Partial<T>;\n  }\n}\n\nexport default omitBy;\n"]}