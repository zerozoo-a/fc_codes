{"version":3,"file":"groupBy.js","sourceRoot":"","sources":["../../src/groupBy.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AAC3D,OAAO,MAAM,MAAM,UAAU,CAAC;AAkD9B,SAAS,OAAO,CAId,CAA0C,EAC1C,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CACL,QAAW,EAC2C,EAAE;YACxD,OAAO,OAAO,CAAC,CAAC,EAAE,QAAe,CAGhC,CAAC;QACJ,CAAC,CAAC;KACH;IAED,MAAM,GAAG,GAAG,EAAsC,CAAC;IACnD,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CACX,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;YACX,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QAC1D,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CACX,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;YACjB,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACvB,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QAC1D,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import Key from \"./types/Key\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport IterableInfer from \"./types/IterableInfer\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport { AsyncFunctionException } from \"./_internal/error\";\nimport reduce from \"./reduce\";\nimport iterableInfer from \"./types/IterableInfer\";\n\n/**\n * Splits Iterable/AsyncIterable into sets, grouped by the result of running each value through `f`.\n *\n * @example\n * ```ts\n * const given = [\n *   { category: \"clothes\", desc: \"good\" },\n *   { category: \"pants\", desc: \"bad\" },\n *   { category: \"shoes\", desc: \"not bad\" },\n *   { category: \"shoes\", desc: \"great\" },\n *   { category: \"pants\", desc: \"good\" },\n * ];\n *\n * groupBy((a) => a.category, given);\n * // {\n * //   clothes: [{ category: \"clothes\", desc: \"good\" }],\n * //   pants: [\n * //     { category: \"pants\", desc: \"bad\" },\n * //     { category: \"pants\", desc: \"good\" },\n * //   ],\n * //   shoes: [\n * //     { category: \"shoes\", desc: \"not bad\" },\n * //     { category: \"shoes\", desc: \"great\" },\n * //   ],\n * // };\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-groupby-v8q3b | Try It}\n */\n\nfunction groupBy<A, B extends Key>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): { [K in B]: A[] };\n\nfunction groupBy<A, B extends Key>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in B]: A[] }>;\n\nfunction groupBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A>[] }>;\n\nfunction groupBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n  iterable?: A,\n):\n  | { [K in B]: IterableInfer<A>[] }\n  | Promise<{ [K in B]: IterableInfer<A>[] }>\n  | ((iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A>[] }>) {\n  if (iterable === undefined) {\n    return (\n      iterable: A,\n    ): ReturnValueType<A, { [K in B]: IterableInfer<A>[] }> => {\n      return groupBy(f, iterable as any) as ReturnValueType<\n        A,\n        { [K in B]: IterableInfer<A>[] }\n      >;\n    };\n  }\n\n  const obj = {} as { [K in B]: IterableInfer<A>[] };\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      (group, a) => {\n        const key = f(a);\n        if (isPromise(key)) {\n          throw new AsyncFunctionException();\n        }\n        return (group[key] || (group[key] = [])).push(a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  if (isAsyncIterable<iterableInfer<A>>(iterable)) {\n    return reduce(\n      async (group, a) => {\n        const key = await f(a);\n        return (group[key] || (group[key] = [])).push(a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default groupBy;\n"]}