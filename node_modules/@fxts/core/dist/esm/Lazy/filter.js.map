{"version":3,"file":"filter.js","sourceRoot":"","sources":["../../../src/Lazy/filter.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\nimport concurrent, { Concurrent, isConcurrent } from \"./concurrent\";\nimport pipe1 from \"../pipe1\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport TruthyTypesOf from \"../types/TrutyTypesOf\";\nimport { Reject, Resolve } from \"../types/Utils\";\nimport { AsyncFunctionException } from \"../_internal/error\";\n\nasync function* asyncSequential<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  for await (const item of iterable) {\n    if (await f(item)) yield item;\n  }\n}\n\nfunction asyncConcurrent<A>(\n  iterable: AsyncIterable<[boolean, A]>,\n): AsyncIterableIterator<A> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  const settlementQueue: [Resolve<A>, Reject][] = [] as unknown as [\n    Resolve<A>,\n    Reject,\n  ][];\n  const buffer: A[] = [];\n  let finished = false;\n  let nextCallCount = 0;\n  let resolvedCount = 0;\n  let prevItem = Promise.resolve();\n\n  function fillBuffer(concurrent: Concurrent) {\n    const nextItem = iterator.next(concurrent as any);\n    prevItem = prevItem\n      .then(() => nextItem)\n      .then(({ done, value }) => {\n        if (done) {\n          while (settlementQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [resolve] = settlementQueue.shift()!;\n            resolve({ done: true, value: undefined });\n          }\n          return void (finished = true);\n        }\n\n        const [cond, item] = value;\n        if (cond) {\n          buffer.push(item);\n        }\n        recur(concurrent);\n      })\n\n      .catch((reason: any) => {\n        finished = true;\n        while (settlementQueue.length > 0) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const [, reject] = settlementQueue.shift()!;\n          reject(reason);\n        }\n      });\n  }\n\n  function consumeBuffer() {\n    while (buffer.length > 0 && nextCallCount > resolvedCount) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const value = buffer.shift()!;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [resolve] = settlementQueue.shift()!;\n      resolve({ done: false, value });\n      resolvedCount++;\n    }\n  }\n\n  function recur(concurrent: Concurrent) {\n    if (finished || nextCallCount === resolvedCount) {\n      return;\n    } else if (buffer.length > 0) {\n      consumeBuffer();\n    } else {\n      fillBuffer(concurrent);\n    }\n  }\n\n  return {\n    async next(concurrent: any) {\n      nextCallCount++;\n      if (finished) {\n        return { done: true, value: undefined };\n      }\n      return new Promise((resolve, reject) => {\n        settlementQueue.push([resolve, reject]);\n        recur(concurrent as Concurrent);\n      });\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\nfunction toFilterIterator<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<[boolean, A]> {\n  const iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(_concurrent) {\n      const { done, value } = await iterator.next(_concurrent);\n      if (done) {\n        return {\n          done: true,\n          value: undefined,\n        } as IteratorReturnResult<undefined>;\n      }\n\n      return pipe1(\n        f(value),\n        (cond) =>\n          ({\n            done,\n            value: [Boolean(cond), value],\n          } as IteratorYieldResult<[boolean, A]>),\n      );\n    },\n  };\n}\n\nfunction async<A>(\n  f: (a: A) => unknown,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let _iterator: AsyncIterator<A>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncConcurrent(\n              concurrent(_concurrent.length, toFilterIterator(f, iterable)),\n            )\n          : asyncSequential(f, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\nfunction* sync<A>(f: (a: A) => unknown, iterable: Iterable<A>) {\n  for (const a of iterable) {\n    const res = f(a);\n\n    if (isPromise(res)) {\n      throw new AsyncFunctionException();\n    }\n\n    if (res) {\n      yield a;\n    }\n  }\n}\n\n/**\n * Return Iterable/AsyncIterable of all elements `f` returns truthy for\n *\n * @example\n * ```ts\n * const iter = filter((a)=> a % 2 === 0, [0, 1, 2, 3, 4, 5, 6]);\n * iter.next() // {done:false, value: 0}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:false, value: 4}\n * iter.next() // {done:false, value: 6}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [0, 1, 2, 3, 4, 5, 6],\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  toAsync,\n *  filter(async a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n *\n * // toAsync\n * await pipe(\n *  [Promise.resolve(0), Promise.resolve(1), Promise.resolve(2), Promise.resolve(3),\n *   Promise.resolve(4), Promise.resolve(5), Promise.resolve(6)],\n *  toAsync,\n *  filter(a => a % 2 === 0),\n *  toArray,\n * ); // [0, 2, 4, 6]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-filter-2ibz2 | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction filter<A>(\n  f: BooleanConstructor,\n  iterable: Iterable<A>,\n): IterableIterator<TruthyTypesOf<A>>;\n\nfunction filter<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: Iterable<A>,\n): IterableIterator<B>;\n\nfunction filter<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction filter<A>(\n  f: BooleanConstructor,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<TruthyTypesOf<A>>;\n\nfunction filter<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<B>;\n\nfunction filter<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction filter<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: BooleanConstructor,\n): (\n  iterable: A,\n) => ReturnIterableIteratorType<A, TruthyTypesOf<IterableInfer<A>>>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends IterableInfer<A>,\n>(\n  f: (a: IterableInfer<A>) => a is B,\n): (iterable: A) => ReturnIterableIteratorType<A, B>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>;\n\nfunction filter<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | IterableIterator<IterableInfer<A>>\n  | IterableIterator<TruthyTypesOf<IterableInfer<A>>>\n  | AsyncIterableIterator<IterableInfer<A>>\n  | AsyncIterableIterator<TruthyTypesOf<IterableInfer<A>>>\n  | ((iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>)\n  | ((\n      iterable: A,\n    ) => ReturnIterableIteratorType<A, TruthyTypesOf<IterableInfer<A>>>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnIterableIteratorType<A, IterableInfer<A>> =>\n      filter(f, iterable as any) as ReturnIterableIteratorType<\n        A,\n        IterableInfer<A>\n      >;\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return sync(f, iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return async(f, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default filter;\n"]}