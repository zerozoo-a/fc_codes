{"version":3,"file":"compress.js","sourceRoot":"","sources":["../../../src/Lazy/compress.ts"],"names":[],"mappings":"AAAA,OAAO,GAAG,MAAM,OAAO,CAAC;AACxB,OAAO,IAAI,MAAM,SAAS,CAAC;AAC3B,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,OAAO,GAAG,MAAM,OAAO,CAAC;AA2CxB,SAAS,QAAQ,CACf,SAAmB,EACnB,QAAY;IAIZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAAE,EAAE;YACrB,OAAO,QAAQ,CACb,SAAS,EACT,QAAe,CACiB,CAAC;QACrC,CAAC,CAAC;KACH;IAED,OAAO,IAAI,CACT,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,EACxB,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,EAChC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,CACO,CAAC;AACrC,CAAC;AAED,eAAe,QAAQ,CAAC","sourcesContent":["import zip from \"./zip\";\nimport pipe from \"../pipe\";\nimport filter from \"./filter\";\nimport map from \"./map\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\n\n/**\n * Returns Iterable/AsyncIterable that filters elements from 'iterable' returning only those that have a corresponding element in 'selectors' that evaluates to 'true'.\n * Stops when either 'iterable' or 'selectors' has been exhausted.\n *\n * @example\n * ```ts\n * const iter1 = compress([false,true,false,false,true],  [1, 2, 3, 4, 5]);\n * iter1.next(); // {value: 2, done:false}\n * iter1.next(); // {value: 5, done:false}\n * iter1.next(); // {value: undefined, done:true }\n *\n * const iter2 = compress([1,0,0,1,0],  \"abcde\");\n * iter2.next(); // {value: \"a\", done:false}\n * iter2.next(); // {value: \"d\", done:false}\n * iter2.next(); // {value: undefined, done:true }\n *\n * // with pipe\n * pipe(\n *   [1, 2, 3],\n *   compress([false, true, true]),\n *   toArray,\n * ); // [2, 3]\n * ```\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction compress<A, B>(\n  selector: Array<A>,\n  iterable: Iterable<B>,\n): IterableIterator<B>;\n\nfunction compress<A, B>(\n  selector: Array<A>,\n  iterable: AsyncIterable<B>,\n): AsyncIterableIterator<B>;\n\nfunction compress<A, B extends Iterable<unknown> | AsyncIterable<unknown>>(\n  selector: Array<A>,\n): (iterable: B) => ReturnIterableIteratorType<B>;\n\nfunction compress<A, B extends Iterable<unknown> | AsyncIterable<unknown>>(\n  selectors: Array<A>,\n  iterable?: B,\n):\n  | ReturnIterableIteratorType<B>\n  | ((iterable: B) => ReturnIterableIteratorType<B>) {\n  if (iterable === undefined) {\n    return (iterable: B) => {\n      return compress(\n        selectors,\n        iterable as any,\n      ) as ReturnIterableIteratorType<B>;\n    };\n  }\n\n  return pipe(\n    zip(selectors, iterable),\n    filter(([selector]) => selector),\n    map(([, value]) => value),\n  ) as ReturnIterableIteratorType<B>;\n}\n\nexport default compress;\n"]}