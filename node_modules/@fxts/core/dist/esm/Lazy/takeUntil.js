import { isAsyncIterable, isIterable, isPromise } from "../_internal/utils.js";
import { AsyncFunctionException } from "../_internal/error.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(f, iterable) {
    for (const item of iterable) {
        yield item;
        const res = f(item);
        if (isPromise(res)) {
            throw new AsyncFunctionException();
        }
        if (res) {
            break;
        }
    }
}
function asyncSequential(f, iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    let end = false;
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            if (end) {
                return { done: true, value: undefined };
            }
            const { done, value } = await iterator.next(_concurrent);
            if (done || end) {
                return { done: true, value: undefined };
            }
            const cond = await f(value);
            if (end) {
                return { done: true, value: undefined };
            }
            if (cond) {
                end = true;
            }
            return { done: false, value };
        },
    };
}
function async(f, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncSequential(f, concurrent(_concurrent.length, iterable))
                    : asyncSequential(f, iterable);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function takeUntil(f, iterable) {
    if (iterable === undefined) {
        return (iterable) => {
            return takeUntil(f, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(f, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default takeUntil;
//# sourceMappingURL=takeUntil.js.map