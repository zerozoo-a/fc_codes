import { isAsyncIterable, isIterable } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(sep, iterable) {
    if (sep === "") {
        return yield* iterable;
    }
    let acc = "";
    let chr = "";
    for (chr of iterable) {
        if (chr === sep) {
            yield acc;
            acc = "";
        }
        else {
            acc += chr;
        }
    }
    if (chr === sep) {
        yield "";
    }
    else if (acc.length > 0) {
        yield acc;
    }
}
async function* asyncSequential(sep, iterable) {
    if (sep === "") {
        return yield* iterable;
    }
    let acc = "";
    let chr = "";
    for await (chr of iterable) {
        if (chr === sep) {
            yield acc;
            acc = "";
        }
        else {
            acc += chr;
        }
    }
    if (chr === sep) {
        yield "";
    }
    else if (acc.length > 0) {
        yield acc;
    }
}
function async(sep, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncSequential(sep, concurrent(_concurrent.length, iterable))
                    : asyncSequential(sep, iterable);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function split(sep, iterable) {
    if (iterable === undefined) {
        return (iterable) => {
            return split(sep, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(sep, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(sep, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default split;
//# sourceMappingURL=split.js.map