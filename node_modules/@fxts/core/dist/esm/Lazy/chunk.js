import take from "./take.js";
import toArray from "../toArray.js";
import { asyncEmpty, empty, isAsyncIterable, isIterable, } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(size, iterable) {
    const iterator = iterable[Symbol.iterator]();
    while (true) {
        const c = toArray(take(size, {
            [Symbol.iterator]() {
                return iterator;
            },
        }));
        if (c.length > 0)
            yield c;
        if (c.length < size)
            return;
    }
}
async function* asyncSequential(size, iterable) {
    let i = 0;
    let items = [];
    for await (const item of iterable) {
        if (i++ < size) {
            items.push(item);
        }
        if (i === size) {
            yield items;
            i = 0;
            items = [];
        }
    }
    if (items.length) {
        yield items;
    }
}
function async(size, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncSequential(size, concurrent(_concurrent.length, iterable))
                    : asyncSequential(size, iterable);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function chunk(size, iterable) {
    if (iterable === undefined) {
        return (iterable) => chunk(size, iterable);
    }
    if (isIterable(iterable)) {
        if (size < 1) {
            return empty();
        }
        else {
            return sync(size, iterable);
        }
    }
    if (isAsyncIterable(iterable)) {
        if (size < 1) {
            return asyncEmpty();
        }
        else {
            return async(size, iterable);
        }
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default chunk;
//# sourceMappingURL=chunk.js.map