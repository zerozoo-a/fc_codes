import pipe1 from "../pipe1.js";
import { empty, isAsyncIterable, isIterable } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
import head from "../head.js";
function* sync(f, acc, iterable) {
    yield acc;
    for (const a of iterable) {
        yield (acc = f(acc, a));
    }
}
async function* asyncSequential(f, acc, iterable) {
    yield acc;
    for await (const a of iterable) {
        yield (acc = pipe1(acc, (acc) => f(acc, a)));
    }
}
function async(f, acc, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncSequential(f, acc, concurrent(_concurrent.length, iterable))
                    : asyncSequential(f, acc, iterable);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function asyncWithoutSeed(f, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                if (isConcurrent(_concurrent)) {
                    const _iterable = concurrent(_concurrent.length, iterable);
                    _iterator = asyncSequential(f, head(_iterable), _iterable);
                }
                else {
                    _iterator = asyncSequential(f, head(iterable), iterable);
                }
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function scan(f, seed, iterable) {
    if (iterable === undefined) {
        if (seed === undefined) {
            return (iterable) => {
                return scan(f, iterable);
            };
        }
        if (isIterable(seed)) {
            const iterator = seed[Symbol.iterator]();
            const { done, value } = iterator.next();
            if (done) {
                return empty();
            }
            return sync(f, value, {
                [Symbol.iterator]() {
                    return iterator;
                },
            });
        }
        if (isAsyncIterable(seed)) {
            return asyncWithoutSeed(f, seed);
        }
        throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
    }
    if (isIterable(iterable)) {
        return sync(f, seed, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, Promise.resolve(seed), iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default scan;
//# sourceMappingURL=scan.js.map