{"version":3,"file":"concat.js","sourceRoot":"","sources":["../../../src/Lazy/concat.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAEjE,QAAQ,CAAC,CAAC,IAAI,CAAI,CAAc,EAAE,CAAc;IAC9C,KAAK,CAAC,CAAC,CAAC,CAAC;IACT,KAAK,CAAC,CAAC,CAAC,CAAC;AACX,CAAC;AAED,SAAS,KAAK,CACZ,CAAmB,EACnB,CAAmB;IAEnB,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB,MAAM,YAAY,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAC/C,MAAM,aAAa,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAChD,OAAO;QACL,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,KAAK,CAAC,IAAI,CAAC,WAAgB;YACzB,MAAM,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,YAAY,CAAC;YACzD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACzD,IAAI,IAAI,EAAE;gBACR,IAAI,QAAQ,KAAK,YAAY,EAAE;oBAC7B,QAAQ,GAAG,IAAI,CAAC;iBACjB;gBACD,OAAO,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aACxC;iBAAM;gBACL,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;aACxB;QACH,CAAC;KACF,CAAC;AACJ,CAAC;AAED,SAAS,eAAe,CACtB,QAAwC;IAExC,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,QAAQ,CAAC;KACjB;IAED,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAiC,CAAC;IAC5E,OAAO;QACL,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,QAAQ,CAAC;QAClB,CAAC;KACF,CAAC;AACJ,CAAC;AAmDD,SAAS,MAAM,CAIb,SAAY,EACZ,SAAa;IAKb,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,OAAO,CAAC,SAAY,EAA0B,EAAE;YAC9C,OAAO,MAAM,CAAC,SAAS,EAAE,SAAS,CAA2B,CAAC;QAChE,CAAC,CAAC;KACH;IAED,IAAI,eAAe,CAAC,SAAS,CAAC,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;QAC5D,kBAAkB;QAClB,OAAO,KAAK,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE,eAAe,CAAC,SAAS,CAAC,CAA2B,CAAC;KAChG;IAED,IAAI,UAAU,CAAC,SAAS,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,EAAE;QAClD,OAAO,IAAI,CAAC,SAAS,EAAE,SAAS,CAA2B,CAAC;KAC7D;IAED,MAAM,IAAI,SAAS,CACjB,mEAAmE,CACpE,CAAC;AACJ,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import IterableInfer from \"../types/IterableInfer\";\nimport ReturnConcatType from \"../types/ReturnConcatType\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\n\nfunction* sync<A>(a: Iterable<A>, b: Iterable<A>): IterableIterator<A> {\n  yield* a;\n  yield* b;\n}\n\nfunction async<A>(\n  a: AsyncIterable<A>,\n  b: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let leftDone = false;\n  const leftIterator = a[Symbol.asyncIterator]();\n  const rightIterator = b[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    async next(_concurrent: any) {\n      const iterator = leftDone ? rightIterator : leftIterator;\n      const { done, value } = await iterator.next(_concurrent);\n      if (done) {\n        if (iterator === leftIterator) {\n          leftDone = true;\n        }\n        return rightIterator.next(_concurrent);\n      } else {\n        return { done, value };\n      }\n    },\n  };\n}\n\nfunction toAsyncIterable<T>(\n  iterable: Iterable<T> | AsyncIterable<T>,\n): AsyncIterable<T> {\n  if (isAsyncIterable(iterable)) {\n    return iterable;\n  }\n\n  const iterator = iterable[Symbol.iterator]() as unknown as AsyncIterator<T>;\n  return {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    },\n  };\n}\n\n/**\n * Returns the result of concatenating the given iterable.\n *\n * @example\n * ```ts\n * const iter = concat([1, 2], [3, 4]);\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:false, value: 3}\n * iter.next() // {done:false, value: 4}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [3, 4],\n *  concat([1, 2]),\n *  toArray,\n * ); // [1, 2, 3, 4]\n *\n * await pipe(\n *  Promise.resolve([3, 4]),\n *  concat([1, 2]),\n *  toArray,\n * ); // [1, 2, 3, 4]\n *\n *  await pipe(\n *  [Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  concat([1, 2]),\n *  toArray,\n * ); // [1, 2, 3, 4]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-concat-mhd7d | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\n// prettier-ignore\nfunction concat<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Iterable<unknown> | AsyncIterable<unknown>\n>(iterable1: A, iterable2: B): ReturnConcatType<A, B>;\n\nfunction concat<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Iterable<unknown> | AsyncIterable<unknown>,\n>(iterable1: A): (iterable2: B) => ReturnConcatType<A, B>;\n\nfunction concat<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Iterable<unknown> | AsyncIterable<unknown>,\n>(\n  iterable1: A,\n  iterable2?: B,\n):\n  | IterableIterator<IterableInfer<A> | IterableInfer<B>>\n  | AsyncIterableIterator<IterableInfer<A> | IterableInfer<B>>\n  | ((iterable2: B) => ReturnConcatType<A, B>) {\n  if (iterable2 === undefined) {\n    return (iterable2: B): ReturnConcatType<A, B> => {\n      return concat(iterable1, iterable2) as ReturnConcatType<A, B>;\n    };\n  }\n\n  if (isAsyncIterable(iterable1) || isAsyncIterable(iterable2)) {\n    // prettier-ignore\n    return async(toAsyncIterable(iterable1), toAsyncIterable(iterable2)) as ReturnConcatType<A, B>;\n  }\n\n  if (isIterable(iterable1) && isIterable(iterable2)) {\n    return sync(iterable1, iterable2) as ReturnConcatType<A, B>;\n  }\n\n  throw new TypeError(\n    \"'iterable1','iterable2' must be type of Iterable or AsyncIterable\",\n  );\n}\n\nexport default concat;\n"]}