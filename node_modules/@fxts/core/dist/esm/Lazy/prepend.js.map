{"version":3,"file":"prepend.js","sourceRoot":"","sources":["../../../src/Lazy/prepend.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAE5E,QAAQ,CAAC,CAAC,IAAI,CAAI,CAAI,EAAE,QAAqB;IAC3C,MAAM,CAAC,CAAC;IACR,KAAK,CAAC,CAAC,QAAQ,CAAC;AAClB,CAAC;AAED,SAAS,KAAK,CACZ,CAAa,EACb,QAA0B;IAE1B,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAClD,OAAO;QACL,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,UAAU;YACnB,IAAI,WAAW,EAAE;gBACf,WAAW,GAAG,KAAK,CAAC;gBACpB,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC;aACxC;YACD,OAAO,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACnC,CAAC;KACF,CAAC;AACJ,CAAC;AAoDD,SAAS,OAAO,CACd,CAAI,EACJ,QAAyC;IAKzC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAAE,EAAE,CACrB,OAAO,CAAC,CAAC,EAAE,QAAe,CAA4B,CAAC;KAC1D;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC/D;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import Awaited from \"../types/Awaited\";\nimport ReturnPrependType from \"../types/ReturnPrependType\";\nimport { isAsyncIterable, isIterable, isPromise } from \"../_internal/utils\";\n\nfunction* sync<A>(a: A, iterable: Iterable<A>): IterableIterator<A> {\n  yield a;\n  yield* iterable;\n}\n\nfunction async<A>(\n  a: Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A> {\n  let isFirstItem = true;\n  const iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(concurrent) {\n      if (isFirstItem) {\n        isFirstItem = false;\n        return { done: false, value: await a };\n      }\n      return iterator.next(concurrent);\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable with the given element at the front,\n * followed by the contents of iterable.\n *\n * @example\n * ```ts\n * const iter = prepend(4, [1, 2, 3]);\n * iter.next() // {done:false, value: 4}\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 2}\n * iter.next() // {done:false, value: 3}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3],\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3]),\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n *  toAsync,\n *  prepend(4),\n *  toArray,\n * ); // [4, 1, 2, 3]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-prepend-70ymx | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction prepend<A>(a: A, iterable: Iterable<A>): IterableIterator<A>;\n\nfunction prepend<A, B extends Iterable<A> | AsyncIterable<Awaited<A>>>(\n  a: A,\n): (iterable: B) => ReturnPrependType<A, B>;\n\nfunction prepend<A>(\n  a: A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction prepend<A, B extends Iterable<A> | AsyncIterable<Awaited<A>>>(\n  a: A,\n  iterable?: Iterable<A> | AsyncIterable<A>,\n):\n  | IterableIterator<A>\n  | AsyncIterableIterator<A>\n  | ((iterable: B) => ReturnPrependType<A, B>) {\n  if (iterable === undefined) {\n    return (iterable: B) =>\n      prepend(a, iterable as any) as ReturnPrependType<A, B>;\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(isPromise(a) ? a : Promise.resolve(a), iterable);\n  }\n\n  if (isIterable(iterable)) {\n    return sync(a, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default prepend;\n"]}