import map from "./map.js";
import pipe from "../pipe.js";
import toArray from "../toArray.js";
import toAsync from "./toAsync.js";
import { isAsyncIterable, isIterable, toIterator } from "../_internal/utils.js";
import range from "./range.js";
import takeWhile from "./takeWhile.js";
import every from "../every.js";
function sync(iterable) {
    const iterators = toArray(map((a) => toIterator(a), iterable));
    return pipe(range(Infinity), map(() => toArray(map((it) => it.next(), iterators))), takeWhile(every((cur2) => !cur2.done)), map((cur1) => toArray(map((cur2) => cur2.value, cur1))));
}
function async(iterable) {
    const iterators = toArray(map(toIterator, iterable));
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            const headIterators = await pipe(toAsync(iterators), map((it) => it.next(_concurrent)), toArray);
            const hasDone = headIterators.some((it) => it.done);
            if (hasDone) {
                return { done: true, value: undefined };
            }
            return {
                done: false,
                value: headIterators.map((it) => it.value),
            };
        },
    };
}
function zip(...iterables) {
    if (iterables.length < 2) {
        return (...iterables2) => {
            return zip(...iterables, ...iterables2);
        };
    }
    if (iterables.some((a) => !isIterable(a) && !isAsyncIterable(a))) {
        throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
    }
    const hasAsyncIterable = iterables.some((iterable) => isAsyncIterable(iterable));
    if (hasAsyncIterable) {
        return async(iterables);
    }
    return sync(iterables);
}
export default zip;
//# sourceMappingURL=zip.js.map