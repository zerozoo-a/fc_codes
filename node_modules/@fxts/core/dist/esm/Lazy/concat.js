import { isAsyncIterable, isIterable } from "../_internal/utils.js";
function* sync(a, b) {
    yield* a;
    yield* b;
}
function async(a, b) {
    let leftDone = false;
    const leftIterator = a[Symbol.asyncIterator]();
    const rightIterator = b[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            const iterator = leftDone ? rightIterator : leftIterator;
            const { done, value } = await iterator.next(_concurrent);
            if (done) {
                if (iterator === leftIterator) {
                    leftDone = true;
                }
                return rightIterator.next(_concurrent);
            }
            else {
                return { done, value };
            }
        },
    };
}
function toAsyncIterable(iterable) {
    if (isAsyncIterable(iterable)) {
        return iterable;
    }
    const iterator = iterable[Symbol.iterator]();
    return {
        [Symbol.asyncIterator]() {
            return iterator;
        },
    };
}
function concat(iterable1, iterable2) {
    if (iterable2 === undefined) {
        return (iterable2) => {
            return concat(iterable1, iterable2);
        };
    }
    if (isAsyncIterable(iterable1) || isAsyncIterable(iterable2)) {
        // prettier-ignore
        return async(toAsyncIterable(iterable1), toAsyncIterable(iterable2));
    }
    if (isIterable(iterable1) && isIterable(iterable2)) {
        return sync(iterable1, iterable2);
    }
    throw new TypeError("'iterable1','iterable2' must be type of Iterable or AsyncIterable");
}
export default concat;
//# sourceMappingURL=concat.js.map