import { isAsyncIterable, isIterable, isPromise } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(a, iterable) {
    yield* iterable;
    yield a;
}
function asyncSequential(a, iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    let finished = false;
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next() {
            if (finished) {
                return { done: true, value: undefined };
            }
            const { value, done } = await iterator.next();
            if (finished) {
                return { done: true, value: undefined };
            }
            if (done) {
                finished = true;
                return { done: false, value: await a };
            }
            else {
                return { done, value };
            }
        },
    };
}
function async(a, iterable) {
    let iterator = null;
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            if (iterator === null) {
                iterator = isConcurrent(_concurrent)
                    ? asyncSequential(a, concurrent(_concurrent.length, iterable))
                    : asyncSequential(a, iterable);
            }
            return iterator.next(_concurrent);
        },
    };
}
function append(a, iterable) {
    if (iterable === undefined) {
        return (iterable) => append(a, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(isPromise(a) ? a : Promise.resolve(a), iterable);
    }
    if (isIterable(iterable)) {
        return sync(a, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default append;
//# sourceMappingURL=append.js.map