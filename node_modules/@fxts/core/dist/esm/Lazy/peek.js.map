{"version":3,"file":"peek.js","sourceRoot":"","sources":["../../../src/Lazy/peek.ts"],"names":[],"mappings":"AAAA,OAAO,GAAG,MAAM,QAAQ,CAAC;AACzB,OAAO,GAAG,MAAM,OAAO,CAAC;AACxB,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAmEjE,SAAS,IAAI,CACX,CAA4C,EAC5C,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAAE,EAAE;YACrB,OAAO,IAAI,CAAC,CAAC,EAAE,QAAe,CAAkC,CAAC;QACnE,CAAC,CAAC;KACH;IAED,IAAI,UAAU,CAA4B,QAAQ,CAAC,EAAE;QACnD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,QAAQ,CAG1B,CAAC;KACH;IAED,IAAI,eAAe,CAA4B,QAAQ,CAAC,EAAE;QACxD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,QAAQ,CAG1B,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,IAAI,CAAC","sourcesContent":["import tap from \"../tap\";\nimport map from \"./map\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport Awaited from \"../types/Awaited\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport IterableInfer from \"../types/IterableInfer\";\n\n/**\n * Iterate over an input list,\n * calling a provided `f` for each element in the Iterable/AsyncIterable.\n * Use it when you want to create an effect inside `pipe`.\n *\n * @example\n * ```ts\n * const iter = peek(a => console.log(a), [1, 2, 3, 4]);\n * iter.next() // {done:false, value: 1} // log 1\n * iter.next() // {done:false, value: 2} // log 2\n * iter.next() // {done:false, value: 3} // log 3\n * iter.next() // {done:false, value: 4} // log 4\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4],\n *  peek(a => console.log(a)),\n *  toArray,\n * ); // [1, 2, 3, 4] // log 1,2,3,4\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  peek(a => console.log(a)),\n *  toArray,\n * ); // [1, 2, 3, 4] // log 1,2,3,4\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  toAsync,\n *  peek(async (a) => console.log(a)),\n *  toArray,\n * ); // [1, 2, 3, 4] // log 1,2,3,4\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  peek(a => console.log(a)),\n *  toArray,\n * ); // [1, 2, 3, 4] // log 1,2,3,4\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-peek-xm1jh | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\n// prettier-ignore\nfunction peek<T>(\n  f: (a: T) => unknown, iterable: Iterable<T>\n): IterableIterator<T>;\n\nfunction peek<T>(\n  f: (a: T) => unknown,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T>;\n\nfunction peek<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: Awaited<IterableInfer<T>>) => unknown,\n): (iterable: T) => ReturnIterableIteratorType<T>;\n\nfunction peek<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (a: Awaited<IterableInfer<T>>) => unknown,\n  iterable?: T,\n):\n  | IterableIterator<Awaited<IterableInfer<T>>>\n  | AsyncIterableIterator<Awaited<IterableInfer<T>>>\n  | ((iterable: T) => ReturnIterableIteratorType<T>) {\n  if (iterable === undefined) {\n    return (iterable: T) => {\n      return peek(f, iterable as any) as ReturnIterableIteratorType<T>;\n    };\n  }\n\n  if (isIterable<Awaited<IterableInfer<T>>>(iterable)) {\n    return map(tap(f), iterable) as ReturnIterableIteratorType<\n      T,\n      Awaited<IterableInfer<T>>\n    >;\n  }\n\n  if (isAsyncIterable<Awaited<IterableInfer<T>>>(iterable)) {\n    return map(tap(f), iterable) as ReturnIterableIteratorType<\n      T,\n      Awaited<IterableInfer<T>>\n    >;\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default peek;\n"]}