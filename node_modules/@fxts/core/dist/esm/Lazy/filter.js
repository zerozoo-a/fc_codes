import { isAsyncIterable, isIterable, isPromise } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
import pipe1 from "../pipe1.js";
import { AsyncFunctionException } from "../_internal/error.js";
async function* asyncSequential(f, iterable) {
    for await (const item of iterable) {
        if (await f(item))
            yield item;
    }
}
function asyncConcurrent(iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    const settlementQueue = [];
    const buffer = [];
    let finished = false;
    let nextCallCount = 0;
    let resolvedCount = 0;
    let prevItem = Promise.resolve();
    function fillBuffer(concurrent) {
        const nextItem = iterator.next(concurrent);
        prevItem = prevItem
            .then(() => nextItem)
            .then(({ done, value }) => {
            if (done) {
                while (settlementQueue.length > 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const [resolve] = settlementQueue.shift();
                    resolve({ done: true, value: undefined });
                }
                return void (finished = true);
            }
            const [cond, item] = value;
            if (cond) {
                buffer.push(item);
            }
            recur(concurrent);
        })
            .catch((reason) => {
            finished = true;
            while (settlementQueue.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const [, reject] = settlementQueue.shift();
                reject(reason);
            }
        });
    }
    function consumeBuffer() {
        while (buffer.length > 0 && nextCallCount > resolvedCount) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const value = buffer.shift();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [resolve] = settlementQueue.shift();
            resolve({ done: false, value });
            resolvedCount++;
        }
    }
    function recur(concurrent) {
        if (finished || nextCallCount === resolvedCount) {
            return;
        }
        else if (buffer.length > 0) {
            consumeBuffer();
        }
        else {
            fillBuffer(concurrent);
        }
    }
    return {
        async next(concurrent) {
            nextCallCount++;
            if (finished) {
                return { done: true, value: undefined };
            }
            return new Promise((resolve, reject) => {
                settlementQueue.push([resolve, reject]);
                recur(concurrent);
            });
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function toFilterIterator(f, iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            const { done, value } = await iterator.next(_concurrent);
            if (done) {
                return {
                    done: true,
                    value: undefined,
                };
            }
            return pipe1(f(value), (cond) => ({
                done,
                value: [Boolean(cond), value],
            }));
        },
    };
}
function async(f, iterable) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncConcurrent(concurrent(_concurrent.length, toFilterIterator(f, iterable)))
                    : asyncSequential(f, iterable);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function* sync(f, iterable) {
    for (const a of iterable) {
        const res = f(a);
        if (isPromise(res)) {
            throw new AsyncFunctionException();
        }
        if (res) {
            yield a;
        }
    }
}
function filter(f, iterable) {
    if (iterable === undefined) {
        return (iterable) => filter(f, iterable);
    }
    if (isIterable(iterable)) {
        return sync(f, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default filter;
//# sourceMappingURL=filter.js.map