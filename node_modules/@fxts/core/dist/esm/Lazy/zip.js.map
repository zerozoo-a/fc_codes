{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../../src/Lazy/zip.ts"],"names":[],"mappings":"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","sourcesContent":["import map from \"./map\";\nimport pipe from \"../pipe\";\nimport toArray from \"../toArray\";\nimport toAsync from \"./toAsync\";\nimport { isAsyncIterable, isIterable, toIterator } from \"../_internal/utils\";\nimport ReturnZipType from \"../types/ReturnZipType\";\nimport range from \"./range\";\nimport takeWhile from \"./takeWhile\";\nimport every from \"../every\";\nimport { UniversalIterable } from \"../types/Utils\";\n\nfunction sync(\n  iterable: Iterable<Iterable<unknown>>,\n): IterableIterator<Iterable<unknown>> {\n  const iterators = toArray(\n    map((a) => toIterator(a), iterable as Iterable<Iterable<unknown>>),\n  );\n\n  return pipe(\n    range(Infinity),\n    map(() => toArray(map((it) => it.next(), iterators))),\n    takeWhile(every((cur2) => !cur2.done)),\n    map((cur1) => toArray(map((cur2) => cur2.value, cur1))),\n  );\n}\n\nfunction async(\n  iterable: Iterable<UniversalIterable>,\n): AsyncIterableIterator<UniversalIterable> {\n  const iterators = toArray(map(toIterator, iterable as any));\n\n  return {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async next(_concurrent) {\n      const headIterators = await pipe(\n        toAsync(iterators),\n        map((it) => it.next(_concurrent)),\n        toArray,\n      );\n\n      const hasDone = headIterators.some((it) => it.done);\n      if (hasDone) {\n        return { done: true, value: undefined };\n      }\n\n      return {\n        done: false,\n        value: headIterators.map((it) => it.value),\n      };\n    },\n  };\n}\n\n/**\n * Merges the values of each of the arrays with the values at the corresponding position together.\n * Useful when you have separate data sources that are coordinated through matching array indices.\n *\n * @example\n * ```ts\n * const iter = zip([1, 2, 3, 4], [5, 6, 7, 8]);\n * iter.next() // {done:false, value: [1, 5]}\n * iter.next() // {done:false, value: [2, 6]}\n * iter.next() // {done:false, value: [3, 7]}\n * iter.next() // {done:false, value: [4, 8]}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [5, 6, 7, 8],\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * ); // [[1, 5], [2, 6], [3, 7], [4, 8]]\n *\n * await pipe(\n *  Promise.resolve([5, 6, 7, 8]),\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(5), Promise.resolve(6), Promise.resolve(7), Promise.resolve(8)],\n *  toAsync,\n *  zip([1, 2, 3, 4]),\n *  toArray,\n * );  // [[1, 5], [2, 6], [3, 7], [4, 8]]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-zip-81jnh | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction zip<T extends UniversalIterable, TS extends UniversalIterable[]>(\n  a: T,\n): (...args: TS) => ReturnZipType<[T, ...TS]>;\n\n// prettier-ignore\nfunction zip<T extends UniversalIterable[]>(\n  ...args: T\n): ReturnZipType<[...T]>;\n\nfunction zip<TS extends UniversalIterable[]>(\n  ...iterables: TS[]\n): ReturnZipType<TS> | ((...iterables: TS[]) => ReturnZipType<TS>) {\n  if (iterables.length < 2) {\n    return (...iterables2: UniversalIterable[]) => {\n      return zip(...iterables, ...iterables2) as ReturnZipType<TS>;\n    };\n  }\n\n  if (iterables.some((a) => !isIterable(a) && !isAsyncIterable(a))) {\n    throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n  }\n\n  const hasAsyncIterable = iterables.some((iterable) =>\n    isAsyncIterable(iterable),\n  );\n\n  if (hasAsyncIterable) {\n    return async(iterables) as ReturnZipType<TS>;\n  }\n\n  return sync(iterables as Iterable<Iterable<unknown>>[]) as ReturnZipType<TS>;\n}\n\nexport default zip;\n"]}