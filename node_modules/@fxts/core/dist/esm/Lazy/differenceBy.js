import map from "./map.js";
import reject from "./reject.js";
import pipe1 from "../pipe1.js";
import toAsync from "./toAsync.js";
import toArray from "../toArray.js";
import uniq from "./uniq.js";
import pipe from "../pipe.js";
import concurrent, { isConcurrent } from "./concurrent.js";
import { isAsyncIterable, isIterable } from "../_internal/utils.js";
function* sync(f, iterable1, iterable2) {
    const set = new Set(map(f, iterable1));
    yield* pipe(iterable2, reject((a) => pipe1(f(a), (b) => set.has(b))), uniq);
}
async function* asyncSequential(f, iterable1, iterable2) {
    const set = new Set(await toArray(map(f, iterable1)));
    yield* pipe(iterable2, reject((a) => pipe1(f(a), (b) => set.has(b))), uniq);
}
function async(f, iterable1, iterable2) {
    let _iterator;
    return {
        async next(_concurrent) {
            if (_iterator === undefined) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncSequential(f, iterable1, concurrent(_concurrent.length, iterable2))
                    : asyncSequential(f, iterable1, iterable2);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function differenceBy(f, iterable1, iterable2) {
    if (isIterable(iterable1) && isIterable(iterable2)) {
        return sync(f, iterable1, iterable2);
    }
    if (isIterable(iterable1) && isAsyncIterable(iterable2)) {
        return async(f, toAsync(iterable1), iterable2);
    }
    if (isAsyncIterable(iterable1) && isIterable(iterable2)) {
        return async(f, iterable1, toAsync(iterable2));
    }
    if (isAsyncIterable(iterable1) && isAsyncIterable(iterable2)) {
        return async(f, iterable1, iterable2);
    }
    throw new TypeError("'iterable1' and 'iterable2' must be type of Iterable or AsyncIterable");
}
export default differenceBy;
//# sourceMappingURL=differenceBy.js.map