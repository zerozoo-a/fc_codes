{"version":3,"file":"intersectionBy.js","sourceRoot":"","sources":["../../../src/Lazy/intersectionBy.ts"],"names":[],"mappings":"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","sourcesContent":["import map from \"./map\";\nimport filter from \"./filter\";\nimport toAsync from \"./toAsync\";\nimport toArray from \"../toArray\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport pipe1 from \"../pipe1\";\nimport pipe from \"../pipe\";\nimport uniq from \"./uniq\";\n\nfunction* sync<T>(\n  f: (a: T) => unknown,\n  iterable1: Iterable<T>,\n  iterable2: Iterable<T>,\n) {\n  const set = new Set(map(f, iterable1));\n\n  yield* pipe(\n    iterable2,\n    filter((a) => pipe1(f(a), (b) => set.has(b))),\n    uniq,\n  );\n}\n\nasync function* asyncSequential<T>(\n  f: (a: T) => unknown,\n  iterable1: AsyncIterable<T>,\n  iterable2: AsyncIterable<T>,\n) {\n  const set = new Set(await toArray(map(f, iterable1)));\n\n  yield* pipe(\n    iterable2,\n    filter((a) => pipe1(f(a), (b) => set.has(b))),\n    uniq,\n  );\n}\n\nfunction async<T>(\n  f: (a: T) => unknown,\n  iterable1: AsyncIterable<T>,\n  iterable2: AsyncIterable<T>,\n): AsyncIterableIterator<T> {\n  let _iterator: AsyncIterator<T>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(\n              f,\n              iterable1,\n              concurrent(_concurrent.length, iterable2),\n            )\n          : asyncSequential(f, iterable1, iterable2);\n      }\n\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable(i.e no duplicate) of all elements in the `iterable2` contained in the `iterable1`.\n * Duplication is determined according to the value returned by applying the supplied `f` to `iterable2`.\n *\n * @example\n * ```ts\n * const iter = intersectionBy(a => a.x, [{ x: 1 }, { x: 4 }], [{ x: 1 },  { x: 2 },  { x: 3 }])\n * iter.next(); // {value: {x: 1, done: false}\n * iter.next(); // {value: undefined, done: true}\n * ```\n */\nfunction intersectionBy<A, B = unknown>(\n  f: (a: A) => B,\n  iterable1: Iterable<A>,\n  iterable2: Iterable<A>,\n): IterableIterator<A>;\n\nfunction intersectionBy<A, B = unknown>(\n  f: (a: A) => B,\n  iterable1: AsyncIterable<A>,\n  iterable2: Iterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction intersectionBy<A, B = unknown>(\n  f: (a: A) => B,\n  iterable1: Iterable<A>,\n  iterable2: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction intersectionBy<A, B = unknown>(\n  f: (a: A) => B,\n  iterable1: AsyncIterable<A>,\n  iterable2: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction intersectionBy<A, B = unknown>(\n  f: (a: A) => B,\n  iterable1: Iterable<A> | AsyncIterable<A>,\n  iterable2: Iterable<A> | AsyncIterable<A>,\n): IterableIterator<A> | AsyncIterableIterator<A> {\n  if (isIterable(iterable1) && isIterable(iterable2)) {\n    return sync(f, iterable1, iterable2);\n  }\n  if (isIterable(iterable1) && isAsyncIterable(iterable2)) {\n    return async(f, toAsync(iterable1), iterable2);\n  }\n  if (isAsyncIterable(iterable1) && isIterable(iterable2)) {\n    return async(f, iterable1, toAsync(iterable2));\n  }\n  if (isAsyncIterable(iterable1) && isAsyncIterable(iterable2)) {\n    return async(f, iterable1, iterable2);\n  }\n\n  throw new TypeError(\n    \"'iterable1' and 'iterable2' must be type of Iterable or AsyncIterable\",\n  );\n}\n\nexport default intersectionBy;\n"]}