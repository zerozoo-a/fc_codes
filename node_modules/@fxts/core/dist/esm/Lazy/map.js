import { isAsyncIterable, isIterable, isPromise } from "../_internal/utils.js";
import { AsyncFunctionException } from "../_internal/error.js";
function sync(f, iterable) {
    const iterator = iterable[Symbol.iterator]();
    return {
        next() {
            const { done, value } = iterator.next();
            if (done) {
                return {
                    done: true,
                    value: undefined,
                };
            }
            const res = f(value);
            if (isPromise(res)) {
                throw new AsyncFunctionException();
            }
            return {
                done: false,
                value: res,
            };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
function async(f, iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    return {
        async next(_concurrent) {
            const { done, value } = await iterator.next(_concurrent);
            if (done)
                return { done, value };
            return {
                done: false,
                value: await f(value),
            };
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function map(f, iterable) {
    if (iterable === undefined) {
        return (iterable) => {
            return map(f, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(f, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default map;
//# sourceMappingURL=map.js.map