{"version":3,"file":"cycle.js","sourceRoot":"","sources":["../../../src/Lazy/cycle.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AACjE,OAAO,UAAU,EAAE,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAExD,QAAQ,CAAC,CAAC,IAAI,CAAI,QAAqB;IACrC,MAAM,GAAG,GAAG,EAAE,CAAC;IACf,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;QACxB,MAAM,CAAC,CAAC;QACR,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACb;IAED,OAAO,GAAG,CAAC,MAAM,EAAE;QACjB,KAAK,MAAM,CAAC,IAAI,GAAG,EAAE;YACnB,MAAM,CAAC,CAAC;SACT;KACF;AACH,CAAC;AAED,KAAK,SAAS,CAAC,CAAC,eAAe,CAC7B,QAA0B;IAE1B,MAAM,GAAG,GAAG,EAAE,CAAC;IACf,IAAI,KAAK,EAAE,MAAM,CAAC,IAAI,QAAQ,EAAE;QAC9B,MAAM,CAAC,CAAC;QACR,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACb;IAED,OAAO,GAAG,CAAC,MAAM,EAAE;QACjB,KAAK,MAAM,CAAC,IAAI,GAAG,EAAE;YACnB,MAAM,CAAC,CAAC;SACT;KACF;AACH,CAAC;AAED,SAAS,KAAK,CAAI,QAA0B;IAC1C,IAAI,SAA2B,CAAC;IAChC,OAAO;QACL,KAAK,CAAC,IAAI,CAAC,WAAgB;YACzB,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,SAAS,GAAG,YAAY,CAAC,WAAW,CAAC;oBACnC,CAAC,CAAC,eAAe,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;oBAC3D,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;aAC/B;YACD,OAAO,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACrC,CAAC;QACD,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC;AACJ,CAAC;AA0BD,SAAS,KAAK,CACZ,QAAW;IAIX,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;KACvB;IACD,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC;KACxB;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,KAAK,CAAC","sourcesContent":["import IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\n\nfunction* sync<T>(iterable: Iterable<T>): IterableIterator<T> {\n  const arr = [];\n  for (const a of iterable) {\n    yield a;\n    arr.push(a);\n  }\n\n  while (arr.length) {\n    for (const a of arr) {\n      yield a;\n    }\n  }\n}\n\nasync function* asyncSequential<T>(\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T> {\n  const arr = [];\n  for await (const a of iterable) {\n    yield a;\n    arr.push(a);\n  }\n\n  while (arr.length) {\n    for (const a of arr) {\n      yield a;\n    }\n  }\n}\n\nfunction async<T>(iterable: AsyncIterable<T>): AsyncIterableIterator<T> {\n  let _iterator: AsyncIterator<T>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(concurrent(_concurrent.length, iterable))\n          : asyncSequential(iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable that infinitely repeats the given Iterable/AsyncIterable\n *\n * @example\n * ```ts\n * const iter = cycle(\"abc\")\n * iter.next(); // {value:\"a\", done: false}\n * iter.next(); // {value:\"b\", done: false}\n * iter.next(); // {value:\"c\", done: false}\n * iter.next(); // {value:\"a\", done: false}\n * iter.next(); // {value:\"b\", done: false}\n *\n * // with pipe\n * pipe(\n *   cycle([1,2,3,4]),\n *   take(5),\n *   toArray,\n * ); // [1,2,3,4,1]\n * ```\n */\nfunction cycle<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iter: A,\n): ReturnIterableIteratorType<A>;\n\nfunction cycle<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  iterable: T,\n):\n  | IterableIterator<IterableInfer<T>>\n  | AsyncIterableIterator<IterableInfer<T>> {\n  if (isIterable<IterableInfer<T>>(iterable)) {\n    return sync(iterable);\n  }\n  if (isAsyncIterable<IterableInfer<T>>(iterable)) {\n    return async(iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default cycle;\n"]}