{"version":3,"file":"chunk.js","sourceRoot":"","sources":["../../../src/Lazy/chunk.ts"],"names":[],"mappings":"AAAA,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,OAAO,MAAM,YAAY,CAAC;AACjC,OAAO,EACL,UAAU,EACV,KAAK,EACL,eAAe,EACf,UAAU,GACX,MAAM,oBAAoB,CAAC;AAG5B,OAAO,UAAU,EAAE,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAExD,QAAQ,CAAC,CAAC,IAAI,CAAI,IAAY,EAAE,QAAqB;IACnD,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IAC7C,OAAO,IAAI,EAAE;QACX,MAAM,CAAC,GAAG,OAAO,CACf,IAAI,CAAC,IAAI,EAAE;YACT,CAAC,MAAM,CAAC,QAAQ,CAAC;gBACf,OAAO,QAAQ,CAAC;YAClB,CAAC;SACF,CAAC,CACH,CAAC;QACF,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC;YAAE,MAAM,CAAC,CAAC;QAC1B,IAAI,CAAC,CAAC,MAAM,GAAG,IAAI;YAAE,OAAO;KAC7B;AACH,CAAC;AAED,KAAK,SAAS,CAAC,CAAC,eAAe,CAC7B,IAAY,EACZ,QAA0B;IAE1B,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,KAAK,GAAQ,EAAE,CAAC;IACpB,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,QAAQ,EAAE;QACjC,IAAI,CAAC,EAAE,GAAG,IAAI,EAAE;YACd,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAClB;QACD,IAAI,CAAC,KAAK,IAAI,EAAE;YACd,MAAM,KAAK,CAAC;YACZ,CAAC,GAAG,CAAC,CAAC;YACN,KAAK,GAAG,EAAE,CAAC;SACZ;KACF;IACD,IAAI,KAAK,CAAC,MAAM,EAAE;QAChB,MAAM,KAAK,CAAC;KACb;AACH,CAAC;AAED,SAAS,KAAK,CACZ,IAAY,EACZ,QAA0B;IAE1B,IAAI,SAA6B,CAAC;IAClC,OAAO;QACL,KAAK,CAAC,IAAI,CAAC,WAAgB;YACzB,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,SAAS,GAAG,YAAY,CAAC,WAAW,CAAC;oBACnC,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;oBACjE,CAAC,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;aACrC;YACD,OAAO,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACrC,CAAC;QACD,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC;AACJ,CAAC;AAkDD,SAAS,KAAK,CACZ,IAAY,EACZ,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAAE,EAAE,CACrB,KAAK,CAAC,IAAI,EAAE,QAAe,CAG1B,CAAC;KACL;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,OAAO,KAAK,EAAE,CAAC;SAChB;aAAM;YACL,OAAO,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAyC,CAAC;SACrE;KACF;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,OAAO,UAAU,EAAE,CAAC;SACrB;aAAM;YACL,OAAO,KAAK,CAAC,IAAI,EAAE,QAAQ,CAA8C,CAAC;SAC3E;KACF;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,KAAK,CAAC","sourcesContent":["import take from \"./take\";\nimport toArray from \"../toArray\";\nimport {\n  asyncEmpty,\n  empty,\n  isAsyncIterable,\n  isIterable,\n} from \"../_internal/utils\";\nimport IterableInfer from \"../types/IterableInfer\";\nimport ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport concurrent, { isConcurrent } from \"./concurrent\";\n\nfunction* sync<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]> {\n  const iterator = iterable[Symbol.iterator]();\n  while (true) {\n    const c = toArray(\n      take(size, {\n        [Symbol.iterator]() {\n          return iterator;\n        },\n      }),\n    );\n    if (c.length > 0) yield c;\n    if (c.length < size) return;\n  }\n}\n\nasync function* asyncSequential<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]> {\n  let i = 0;\n  let items: T[] = [];\n  for await (const item of iterable) {\n    if (i++ < size) {\n      items.push(item);\n    }\n    if (i === size) {\n      yield items;\n      i = 0;\n      items = [];\n    }\n  }\n  if (items.length) {\n    yield items;\n  }\n}\n\nfunction async<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]> {\n  let _iterator: AsyncIterator<T[]>;\n  return {\n    async next(_concurrent: any) {\n      if (_iterator === undefined) {\n        _iterator = isConcurrent(_concurrent)\n          ? asyncSequential(size, concurrent(_concurrent.length, iterable))\n          : asyncSequential(size, iterable);\n      }\n      return _iterator.next(_concurrent);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Returns Iterable/AsyncIterable of elements split into groups the length of size.\n * If iterableIterator can't be split evenly, the final chunk will be the remaining elements.\n *\n * @example\n * ```ts\n * const iter = chunk(2, [1, 2, 3, 4]);\n * iter.next() // {done:false, value:[1, 2]}\n * iter.next() // {done:false, value:[3, 4]}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4],\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3 ,4]),\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  chunk(2),\n *  toArray,\n * ); // [[1, 2],[3, 4]]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-chunk-gksly | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\nfunction chunk<T>(size: number, iterable: Iterable<T>): IterableIterator<T[]>;\nfunction chunk<T>(\n  size: number,\n  iterable: AsyncIterable<T>,\n): AsyncIterableIterator<T[]>;\n\nfunction chunk<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  size: number,\n): (iterable: T) => ReturnIterableIteratorType<T, IterableInfer<T>[]>;\n\nfunction chunk<T extends Iterable<unknown> | AsyncIterable<unknown>>(\n  size: number,\n  iterable?: T,\n):\n  | IterableIterator<IterableInfer<T>[]>\n  | AsyncIterableIterator<IterableInfer<T>[]>\n  | ((iterable: T) => ReturnIterableIteratorType<T, IterableInfer<T>[]>) {\n  if (iterable === undefined) {\n    return (iterable: T) =>\n      chunk(size, iterable as any) as ReturnIterableIteratorType<\n        T,\n        IterableInfer<T>[]\n      >;\n  }\n\n  if (isIterable(iterable)) {\n    if (size < 1) {\n      return empty();\n    } else {\n      return sync(size, iterable) as IterableIterator<IterableInfer<T>[]>;\n    }\n  }\n\n  if (isAsyncIterable(iterable)) {\n    if (size < 1) {\n      return asyncEmpty();\n    } else {\n      return async(size, iterable) as AsyncIterableIterator<IterableInfer<T>[]>;\n    }\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default chunk;\n"]}