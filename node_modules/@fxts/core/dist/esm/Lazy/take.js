import { isAsyncIterable, isIterable } from "../_internal/utils.js";
function* sync(length, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let cur = null;
    while (length-- > 0 && (cur = iterator.next()).done === false) {
        yield cur.value;
    }
}
function async(length, iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            if (length-- < 1)
                return { done: true, value: undefined };
            return iterator.next(_concurrent);
        },
    };
}
function take(l, iterable) {
    if (iterable === undefined) {
        return (iterable) => {
            return take(l, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(l, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(l, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default take;
//# sourceMappingURL=take.js.map