import concurrent, { isConcurrent } from "./concurrent.js";
import last from "../last.js";
import { empty, isAsyncIterable, isIterable } from "../_internal/utils.js";
import append from "./append.js";
import concat from "./concat.js";
const isFlatAble = function (a) {
    return typeof a !== "string" && isIterable(a);
};
function sync(iterable, depth) {
    const iterator = iterable[Symbol.iterator]();
    const iteratorStack = [
        iterator,
    ];
    return {
        [Symbol.iterator]() {
            return this;
        },
        next() {
            const iterator = last(iteratorStack);
            if (!iterator) {
                return { done: true, value: undefined };
            }
            const { value, done } = iterator.next();
            if (done) {
                iteratorStack.pop();
                return this.next();
            }
            if (isFlatAble(value) && iteratorStack.length < depth + 1) {
                iteratorStack.push(value[Symbol.iterator]());
                return this.next();
            }
            return {
                done: false,
                value,
            };
        },
    };
}
function asyncConcurrent(iterable, depth) {
    const originIterator = iterable[Symbol.asyncIterator]();
    let prevItem = Promise.resolve();
    let flattenIterator = empty();
    let finished = false;
    const settlementQueue = [];
    const fillItem = async () => {
        const { done, value } = await originIterator.next();
        if (done) {
            return false;
        }
        if (isFlatAble(value)) {
            flattenIterator = concat(sync(value, depth - 1), flattenIterator);
        }
        else {
            flattenIterator = append(value, flattenIterator);
        }
        return true;
    };
    const pullItem = async () => {
        if (finished) {
            return { done: true, value: undefined };
        }
        const { value, done } = flattenIterator.next();
        if (done) {
            const hasItem = await fillItem();
            if (hasItem) {
                return pullItem();
            }
            return { done: true, value: undefined };
        }
        return { done: false, value };
    };
    const resolveItem = ({ done, value }) => {
        if (done || finished) {
            while (settlementQueue.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const [resolve] = settlementQueue.shift();
                resolve({ done: true, value: undefined });
            }
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const [resolve] = settlementQueue.shift();
        resolve({ done, value });
    };
    const catchItem = (err) => {
        finished = true;
        // eslint-disable-next-line
        const [_, reject] = settlementQueue.shift();
        reject(err);
    };
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next() {
            return new Promise((resolve, reject) => {
                settlementQueue.push([resolve, reject]);
                prevItem = prevItem
                    .then(() => pullItem())
                    .then(resolveItem)
                    .catch(catchItem);
            });
        },
    };
}
function asyncSequential(iterable, depth) {
    const iterator = iterable[Symbol.asyncIterator]();
    const iteratorStack = [
        iterator,
    ];
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next() {
            const iterator = last(iteratorStack);
            if (!iterator) {
                return { done: true, value: undefined };
            }
            const { value, done } = await iterator.next();
            if (done) {
                iteratorStack.pop();
                return this.next();
            }
            if (isFlatAble(value) && iteratorStack.length < depth + 1) {
                iteratorStack.push(value[Symbol.iterator]());
                return this.next();
            }
            return {
                done: false,
                value,
            };
        },
    };
}
function async(iterable, depth) {
    let _iterator = null;
    return {
        async next(_concurrent) {
            if (_iterator === null) {
                _iterator = isConcurrent(_concurrent)
                    ? asyncConcurrent(concurrent(_concurrent.length, iterable), depth)
                    : asyncSequential(iterable, depth);
            }
            return _iterator.next(_concurrent);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function flat(iterable, depth = 1) {
    if (isIterable(iterable)) {
        return sync(iterable, depth);
    }
    if (isAsyncIterable(iterable)) {
        return async(iterable, depth);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default flat;
//# sourceMappingURL=flat.js.map