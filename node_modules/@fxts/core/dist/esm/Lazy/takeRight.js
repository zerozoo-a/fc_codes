import { isAsyncIterable, isIterable } from "../_internal/utils.js";
import toArray from "../toArray.js";
import isArray from "../isArray.js";
import isString from "../isString.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(length, iterable) {
    const arr = isArray(iterable) || isString(iterable) ? iterable : toArray(iterable);
    const index = arr.length - length;
    for (let i = index; i < arr.length; i++) {
        if (arr[i])
            yield arr[i];
    }
}
async function* asyncSequential(length, iterable) {
    const arr = await toArray(iterable);
    const index = arr.length - length;
    for (let i = index; i < arr.length; i++) {
        if (arr[i]) {
            yield arr[i];
        }
    }
}
function async(length, iterable) {
    let iterator;
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        next(_concurrent) {
            if (iterator === undefined) {
                iterator = isConcurrent(_concurrent)
                    ? asyncSequential(length, concurrent(_concurrent.length, iterable))
                    : asyncSequential(length, iterable);
            }
            return iterator.next(_concurrent);
        },
    };
}
function takeRight(l, iterable) {
    if (l < 0) {
        throw new RangeError("'length' must be greater than 0");
    }
    if (iterable === undefined) {
        return (iterable) => {
            return takeRight(l, iterable);
        };
    }
    if (isIterable(iterable)) {
        return sync(l, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(l, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default takeRight;
//# sourceMappingURL=takeRight.js.map