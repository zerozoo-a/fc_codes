import isNumber from "../isNumber.js";
import { isAsyncIterable, isIterable } from "../_internal/utils.js";
import concurrent, { isConcurrent } from "./concurrent.js";
function* sync(start, end, iterable) {
    let i = 0;
    for (const item of iterable) {
        if (i >= start && i < end) {
            yield item;
        }
        i += 1;
    }
}
async function* asyncSequential(start, end, iterable) {
    let i = 0;
    for await (const item of iterable) {
        if (i >= start && i < end) {
            yield item;
        }
        i += 1;
    }
}
function async(start, end, iterable) {
    let iterator;
    return {
        [Symbol.asyncIterator]() {
            return this;
        },
        async next(_concurrent) {
            if (iterator === undefined) {
                // prettier-ignore
                iterator = isConcurrent(_concurrent)
                    ? asyncSequential(start, end, concurrent(_concurrent.length, iterable))
                    : asyncSequential(start, end, iterable);
            }
            return iterator.next(_concurrent);
        },
    };
}
function _slice(start, end, iterable) {
    if (!isNumber(start) || !isNumber(end)) {
        throw new TypeError("'start' and 'end' must be type of number");
    }
    if (isIterable(iterable)) {
        return sync(start, end, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(start, end, iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
function slice(start, end, iterable) {
    if (iterable === undefined) {
        if (end === undefined) {
            return (iterable) => {
                return _slice(start, Infinity, iterable);
            };
        }
        if (isIterable(end) || isAsyncIterable(end)) {
            return _slice(start, Infinity, end);
        }
        if (isNumber(end)) {
            return (iterable) => {
                return _slice(start, end, iterable);
            };
        }
        return (iterable) => {
            return _slice(0, Infinity, iterable);
        };
    }
    return _slice(start, end, iterable);
}
export default slice;
//# sourceMappingURL=slice.js.map