{"version":3,"file":"each.js","sourceRoot":"","sources":["../../src/each.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAE3E,SAAS,IAAI,CAAiB,CAAc,EAAE,QAAqB;IACjE,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;QACxB,CAAC,CAAC,CAAC,CAAC,CAAC;KACN;AACH,CAAC;AAED,KAAK,UAAU,KAAK,CAClB,CAAc,EACd,QAA0B;IAE1B,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,QAAQ,EAAE;QACjC,MAAM,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QACtB,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;YACpB,MAAM,KAAK,CAAC;SACb;KACF;AACH,CAAC;AA4BD,SAAS,IAAI,CACX,CAA6B,EAC7B,QAAY;IAEZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAA4B,EAAE;YAC/C,OAAO,IAAI,CAAC,CAAC,EAAE,QAAe,CAA6B,CAAC;QAC9D,CAAC,CAAC;KACH;IAED,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC1B;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KAC3B;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,IAAI,CAAC","sourcesContent":["import IterableInfer from \"./types/IterableInfer\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\n\nfunction sync<A, B = unknown>(f: (a: A) => B, iterable: Iterable<A>): void {\n  for (const a of iterable) {\n    f(a);\n  }\n}\n\nasync function async<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<void> {\n  for await (const item of iterable) {\n    const value = f(item);\n    if (isPromise(value)) {\n      await value;\n    }\n  }\n}\n\n/**\n * Iterates over Iterable/AsyncIterable, applying each in turn to `f`.\n *\n * @example\n * ```ts\n * each(console.log, [1, 2, 3]); // log 1, 2, 3\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-each-kvz6w | Try It}\n */\n// prettier-ignore\nfunction each<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>\n): void;\n\nfunction each<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<void>;\n\nfunction each<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(f: (a: IterableInfer<A>) => B): (iterable: A) => ReturnValueType<A, void>;\n\nfunction each<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): void | Promise<void> | ((iterable: A) => ReturnValueType<A, void>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnValueType<A, void> => {\n      return each(f, iterable as any) as ReturnValueType<A, void>;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return sync(f, iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return async(f, iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default each;\n"]}