{"version":3,"file":"reduce.js","sourceRoot":"","sources":["../../src/reduce.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,SAAS,CAAC;AAI5B,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,MAAM,mBAAmB,CAAC;AAEhE,SAAS,IAAI,CAAO,CAAoB,EAAE,GAAM,EAAE,QAAqB;IACrE,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;QACxB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;KACjB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,KAAK,UAAU,KAAK,CAClB,CAAoB,EACpB,GAAe,EACf,QAA0B;IAE1B,IAAI,KAAK,EAAE,MAAM,CAAC,IAAI,QAAQ,EAAE;QAC9B,mCAAmC;QACnC,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,GAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;KACjD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAwFD,SAAS,MAAM,CACb,CAAmC,EACnC,IAAuE,EACvE,QAAuE;IAMvE,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,IAAI,IAAI,KAAK,SAAS,EAAE;YACtB,OAAO,CAAC,QAAW,EAAE,EAAE,CACrB,MAAM,CAAC,CAAC,EAAE,QAAe,CAA0B,CAAC;SACvD;QAED,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;YACzC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YACxC,IAAI,IAAI,EAAE;gBACR,OAAO,SAAS,CAAC;aAClB;YACD,OAAO,IAAI,CAAC,CAAC,EAAE,KAAU,EAAE;gBACzB,CAAC,MAAM,CAAC,QAAQ,CAAC;oBACf,OAAO,QAAQ,CAAC;gBAClB,CAAC;aACF,CAAC,CAAC;SACJ;QAED,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;YACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;YAC9C,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;gBAC9C,IAAI,IAAI,EAAE;oBACR,OAAO,SAAS,CAAC;iBAClB;gBACD,OAAO,KAAK,CAAC,CAAC,EAAE,KAAmB,EAAE;oBACnC,CAAC,MAAM,CAAC,aAAa,CAAC;wBACpB,OAAO,QAAQ,CAAC;oBAClB,CAAC;iBACF,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;SACJ;QAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;KAC7E;IAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC,EAAE,IAAS,EAAE,QAAQ,CAAC,CAAC;KACrC;IAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,IAAS,CAAC,EAAE,QAAQ,CAAC,CAAC;KACvD;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["import pipe1 from \"./pipe1\";\nimport Arrow from \"./types/Arrow\";\nimport IterableInfer from \"./types/IterableInfer\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport { isAsyncIterable, isIterable } from \"./_internal/utils\";\n\nfunction sync<A, B>(f: (a: B, b: A) => B, acc: B, iterable: Iterable<A>): B {\n  for (const a of iterable) {\n    acc = f(acc, a);\n  }\n  return acc;\n}\n\nasync function async<A, B>(\n  f: (a: B, b: A) => B,\n  acc: Promise<B>,\n  iterable: AsyncIterable<A>,\n) {\n  for await (const a of iterable) {\n    // becauseof using es5, use `await`\n    acc = await pipe1(acc, (acc) => f(acc as B, a));\n  }\n  return acc;\n}\n\n/**\n * Also known as foldl, this method boils down a list of values into a single value.\n *\n * @example\n * ```ts\n * const sum = (a:number, b:number) => a + b;\n * reduce(sum, [1, 2, 3, 4]); // 10\n * reduce(sum, 0, [1, 2, 3, 4]); // 10\n *\n * // with pipe\n * pipe(\n *  [1, 2, 3, 4],\n *  map(a => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n *\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  map((a) => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([1, 2, 3, 4]),\n *  toAsync,\n *  map(async (a) => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4)],\n *  toAsync,\n *  map(a => a + 10),\n *  filter(a => a % 2 === 0),\n *  reduce(sum),\n * ); // 26\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-reduce-tf56j  | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/map | map}, {@link https://fxts.dev/docs/filter | filter}\n */\n\nfunction reduce<A extends readonly []>(f: Arrow, iterable: A): undefined;\n\nfunction reduce<A extends readonly [], B>(f: Arrow, seed: B, iterable: A): B;\n\nfunction reduce<A>(f: (a: A, b: A) => A, iterable: Iterable<A>): A;\n\nfunction reduce<A, B>(f: (a: B, b: A) => B, iterable: Iterable<A>): B;\n\nfunction reduce<A, B>(f: (a: B, b: A) => B, seed: B, iterable: Iterable<A>): B;\n\nfunction reduce<A>(\n  f: (a: A, b: A) => A,\n  iterable: AsyncIterable<A>,\n): Promise<A>;\n\nfunction reduce<A, B>(\n  f: (a: B, b: A) => B | Promise<B>,\n  seed: B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<B>;\n\nfunction reduce<A, B>(\n  f: (a: B, b: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<B>;\n\nfunction reduce<A extends Iterable<unknown> | AsyncIterable<unknown>>(\n  f: (\n    a: IterableInfer<A>,\n    b: IterableInfer<A>,\n  ) => IterableInfer<A> | Promise<IterableInfer<A>>,\n): (iterable: A) => ReturnValueType<A, IterableInfer<A>>;\n\nfunction reduce<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: B, b: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, B>;\n\nfunction reduce<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: B, b: IterableInfer<A>) => B,\n  seed?: B | Iterable<IterableInfer<A>> | AsyncIterable<IterableInfer<A>>,\n  iterable?: Iterable<IterableInfer<A>> | AsyncIterable<IterableInfer<A>>,\n):\n  | B\n  | undefined\n  | Promise<B | undefined>\n  | ((iterable: A) => ReturnValueType<A, B>) {\n  if (iterable === undefined) {\n    if (seed === undefined) {\n      return (iterable: A) =>\n        reduce(f, iterable as any) as ReturnValueType<A, B>;\n    }\n\n    if (isIterable(seed)) {\n      const iterator = seed[Symbol.iterator]();\n      const { done, value } = iterator.next();\n      if (done) {\n        return undefined;\n      }\n      return sync(f, value as B, {\n        [Symbol.iterator]() {\n          return iterator;\n        },\n      });\n    }\n\n    if (isAsyncIterable(seed)) {\n      const iterator = seed[Symbol.asyncIterator]();\n      return iterator.next().then(({ done, value }) => {\n        if (done) {\n          return undefined;\n        }\n        return async(f, value as Promise<B>, {\n          [Symbol.asyncIterator]() {\n            return iterator;\n          },\n        });\n      });\n    }\n\n    throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n  }\n\n  if (isIterable(iterable)) {\n    return sync(f, seed as B, iterable);\n  }\n\n  if (isAsyncIterable(iterable)) {\n    return async(f, Promise.resolve(seed as B), iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default reduce;\n"]}