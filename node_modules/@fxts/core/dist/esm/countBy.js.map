{"version":3,"file":"countBy.js","sourceRoot":"","sources":["../../src/countBy.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AAC3D,OAAO,MAAM,MAAM,UAAU,CAAC;AAE9B,SAAS,MAAM,CAAgB,MAA4B,EAAE,CAAI;IAC/D,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1C,OAAO,MAAM,CAAC;AAChB,CAAC;AA6CD,SAAS,OAAO,CAId,CAA0C,EAC1C,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAA4C,EAAE;YAC/D,OAAO,OAAO,CAAC,CAAC,EAAE,QAAe,CAGhC,CAAC;QACJ,CAAC,CAAC;KACH;IAED,MAAM,GAAG,GAAG,EAA0B,CAAC;IAEvC,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CACX,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;YACX,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAC5B,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CACX,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;YACjB,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACvB,OAAO,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAC5B,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import Key from \"./types/Key\";\nimport ReturnValueType from \"./types/ReturnValueType\";\nimport IterableInfer from \"./types/IterableInfer\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport { AsyncFunctionException } from \"./_internal/error\";\nimport reduce from \"./reduce\";\n\nfunction incSel<B extends Key>(parent: { [K in B]: number }, k: B) {\n  parent[k] ? parent[k]++ : (parent[k] = 1);\n  return parent;\n}\n\n/**\n * Returns a count for the number of objects in each group.\n * Similar to groupBy, but instead of returning a list of values,\n * it returns a count for the number of values in that group.\n *\n * @example\n * ```ts\n * const given = [\n *   { category: \"clothes\", desc: \"good\" },\n *   { category: \"pants\", desc: \"bad\" },\n *   { category: \"shoes\", desc: \"not bad\" },\n *   { category: \"shoes\", desc: \"great\" },\n *   { category: \"pants\", desc: \"good\" },\n * ];\n *\n * countBy((a) => a.category, given);\n * //{\n * //  clothes: 1,\n * //  pants: 2,\n * //  shoes: 2,\n * // };\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-countby-09t7z | Try It}\n */\n\nfunction countBy<A, B extends Key>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): { [K in B]: number };\n\nfunction countBy<A, B extends Key>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in B]: number }>;\n\nfunction countBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, { [K in B]: number }>;\n\nfunction countBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n  iterable?: A,\n):\n  | { [K in B]: number }\n  | Promise<{ [K in B]: number }>\n  | ((iterable: A) => ReturnValueType<A, { [K in B]: number }>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnValueType<A, { [K in B]: number }> => {\n      return countBy(f, iterable as any) as ReturnValueType<\n        A,\n        { [K in B]: number }\n      >;\n    };\n  }\n\n  const obj = {} as { [K in B]: number };\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      (group, a) => {\n        const key = f(a);\n        if (isPromise(key)) {\n          throw new AsyncFunctionException();\n        }\n        return incSel(group, key);\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      async (group, a) => {\n        const key = await f(a);\n        return incSel(group, key);\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default countBy;\n"]}