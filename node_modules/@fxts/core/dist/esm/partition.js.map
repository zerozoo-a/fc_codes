{"version":3,"file":"partition.js","sourceRoot":"","sources":["../../src/partition.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,OAAO,MAAM,WAAW,CAAC;AAChC,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AAmD3D,SAAS,SAAS,CAChB,CAA6B,EAC7B,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CAAC,QAAW,EAA0B,EAAE;YAC7C,OAAO,SAAS,CAAC,CAAC,EAAE,QAAe,CAA2B,CAAC;QACjE,CAAC,CAAC;KACH;IAED,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YAC1B,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QAC3B,CAAC,EAAE,QAAQ,CAAC,CAAC;QACb,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;KACpD;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;QACvE,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;KAC3E;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,SAAS,CAAC","sourcesContent":["import IterableInfer from \"./types/IterableInfer\";\nimport ReturnPartitionType from \"./types/ReturnPartitionType\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport groupBy from \"./groupBy\";\nimport { AsyncFunctionException } from \"./_internal/error\";\n\n/**\n * Split Iterable/AsyncIterable into two arrays:\n * one with all elements which satisfies `f` and the other with all elements that does not.\n *\n * @example\n * ```ts\n * partition((a) => a % 2 === 0, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]\n *\n * // with pipe\n * pipe(\n *   [1, 2, 3, 4, 5],\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * await pipe(\n *   Promise.resolve([1, 2, 3, 4, 5]),\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *   Promise.resolve([1, 2, 3, 4, 5]),\n *   toAsync,\n *   partition(async (a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * // with toAsync\n * await pipe(\n *   [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4), Promise.resolve(5)],\n *   toAsync,\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-partition-7vns0 | Try It}\n *\n *  see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync}\n */\nfunction partition<A, B>(f: (a: A) => B, iterable: Iterable<A>): [A[], A[]];\n\nfunction partition<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<[A[], A[]]>;\n\nfunction partition<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnPartitionType<A>;\n\nfunction partition<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | [IterableInfer<A>[], IterableInfer<A>[]]\n  | Promise<[IterableInfer<A>[], IterableInfer<A>[]]>\n  | ((iterable: A) => ReturnPartitionType<A>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnPartitionType<A> => {\n      return partition(f, iterable as any) as ReturnPartitionType<A>;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    const group = groupBy((a) => {\n      const key = f(a);\n      if (isPromise(key)) {\n        throw new AsyncFunctionException();\n      }\n      return `${Boolean(key)}`;\n    }, iterable);\n    return [group[\"true\"] || [], group[\"false\"] || []];\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    const group = groupBy(async (a) => `${Boolean(await f(a))}`, iterable);\n    return group.then((group) => [group[\"true\"] || [], group[\"false\"] || []]);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default partition;\n"]}