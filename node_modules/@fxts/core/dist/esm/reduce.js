import pipe1 from "./pipe1.js";
import { isAsyncIterable, isIterable } from "./_internal/utils.js";
function sync(f, acc, iterable) {
    for (const a of iterable) {
        acc = f(acc, a);
    }
    return acc;
}
async function async(f, acc, iterable) {
    for await (const a of iterable) {
        // becauseof using es5, use `await`
        acc = await pipe1(acc, (acc) => f(acc, a));
    }
    return acc;
}
function reduce(f, seed, iterable) {
    if (iterable === undefined) {
        if (seed === undefined) {
            return (iterable) => reduce(f, iterable);
        }
        if (isIterable(seed)) {
            const iterator = seed[Symbol.iterator]();
            const { done, value } = iterator.next();
            if (done) {
                return undefined;
            }
            return sync(f, value, {
                [Symbol.iterator]() {
                    return iterator;
                },
            });
        }
        if (isAsyncIterable(seed)) {
            const iterator = seed[Symbol.asyncIterator]();
            return iterator.next().then(({ done, value }) => {
                if (done) {
                    return undefined;
                }
                return async(f, value, {
                    [Symbol.asyncIterator]() {
                        return iterator;
                    },
                });
            });
        }
        throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
    }
    if (isIterable(iterable)) {
        return sync(f, seed, iterable);
    }
    if (isAsyncIterable(iterable)) {
        return async(f, Promise.resolve(seed), iterable);
    }
    throw new TypeError("'iterable' must be type of Iterable or AsyncIterable");
}
export default reduce;
//# sourceMappingURL=reduce.js.map